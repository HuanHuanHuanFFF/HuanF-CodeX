# D. 音乐预测

link: https://codeforces.com/contest/2042/problem/D

**标签**：扫描线、区间覆盖、离线处理、平衡树、有序集合、对称化

**本质思路**  
通过离线处理（按左端排序）和有序集合（`std::set.lower_bound`）将时间复杂度从 $O(n^2)$ 降到 $O(n\log n)$。

**关键步骤**

1. **离线排序**  
   将所有区间按 $(l\ ↑,\ r\ ↓)$ 排序，保证遍历到 $[l_i,r_i]$ 时，所有满足 $l_j\le l_i$ 的候选 predictors 已加入数据结构。
2. **在线查询**  
   用 `set<int>` 存放已处理区间的右端点，在遍历时用 `lower_bound(r_i)` 找到最小的 $r_j\ge r_i$，即 predictors 交集的右端，累加
   $\max(0,\,r_j - r_i)$。
3. **对称化处理**  
   将区间映射为 $[-r,-l]$ 后复用同样流程，得到左端推荐长度 $\max(0,\,l_i - L)$。
4. **去重**  
   相同原始区间的用户答案置 0。

整体复杂度：两次 $O(n\log n)$ 扫描，合计 $O(n\log n)$。

# K. 渡劫

link: https://codeforces.com/gym/105423

**标签**：状态扩展、分层图、Dijkstra、最短路、超级源

**本质思路**  
将“一次免费通道”作为状态扩展成两层节点（未用/已用），再连同“直接完成渡劫”的超级源边，转化为单源最短路问题，最后取“已用免费”层最短路的最大值。

**关键步骤**

1. **状态扩展**  
   将每个岛屿 $i$ 拆为两层节点：$i^{(0)}$（未用免费）与 $i^{(1)}$（已用免费）。

2. **同层建边**  
   对每条隧道 $(u,v)$ 权重 $w$，在层0和层1分别添加双向边 $(u\leftrightarrow v)$ 权重 $w$。

3. **跨层免费边**  
   在层0的 $(u^{(0)}\to v^{(1)})$ 和 $(v^{(0)}\to u^{(1)})$ 各添加一条权重 $0$ 的边，模拟一次免费穿越。

4. **自跨层跳转**  
   在每个节点添加 $(i^{(0)}\to i^{(1)})$ 权重 $0$ 的边，以支持“在岛上直接用免费机会”情形。

5. **超级源建模**  
   添加源点 $S$，$，对每个 i^{(0)} 添加边 (S\to i^{(0)}) 权重 $a_i，表示不走隧道直接在岛上完成渡劫的消耗。

6. **跑 Dijkstra**  
   在包含 $2n+1$ 个节点的分层图上，从 $S$ 出发求最短路。

7. **结果聚合**  
   答案为所有“已用免费层”节点 $\max_{1\le i\le n} \mathrm{dist}(i^{(1)})$。

整体复杂度：$O((n+m)\log(n+m))$

# D. 禁止前缀

link: https://atcoder.jp/contests/abc403/tasks/abc403_d

**标签**：计数、分组 DP、二状态 DP

**本质思路**  
将所有元素按索引对 _d_ 取模分为 _d_ 组，在每组内做二状态线性 DP：对每个值选择“删除/保留”，用 `dp0`/`dp1`
分别维护上一个位置删除或保留的最小删除数，从而计算该组最少需要删除多少元素，最终累加得答案。

**关键步骤**

1. **统计频次**  
   用 `cnt[x]` 记录每个值 x 在序列中出现的次数。
2. **处理 d=0**  
   若 _d_ == 0，则每个值只能保留一个，删除次数为 ∑(cnt[x]−1)。
3. **分组遍历**  
   对 `r` 从 0 到 _d−1_：
    - 初始化 `dp0=0, dp1=0`
    - 按 `i = r; i < A; i += d` 遍历该组所有值（A 为数值上限）：
        - 令 `c = cnt[i]`
        - `ndp0 = min(dp0, dp1) + c` （删除当前，需删 c 个）
        - `ndp1 = dp0` （保留当前，则上一个必须删）
        - 更新 `dp0=ndp0, dp1=ndp1`
    - 该组最少删除 `min(dp0, dp1)`，累加到总答案
4. **输出答案**  
   累加所有组的最少删除次数即为最终最少删除数

整体复杂度：O(n + A)，空间复杂度 O(A)

# D. ABC400-D 高桥买鱼

link: https://atcoder.jp/contests/abc400/tasks/abc400_d

**标签**：图论、0-1 BFS、最短路、网格图

**本质思路**  
将每个格子视作图的节点，邻接无墙一步移动为权值 0 边，遇墙或跨越障碍为权值 1 边，使用 0-1 BFS 在双端队列中维护最少踢墙次数

**关键步骤**

1. **建模图结构**
    - 节点：(i,j) 对应网格格点
    - 边：对四个方向尝试一步或两步移动
        - 若移动过程中未遇墙且步长=1，权值 0
        - 否则视为“踢墙”，权值 1
2. **0-1 BFS**
    - 初始化 `hit[sx][sy] = 0`，将起点 `(sx,sy)` 加入 `deque`
    - 每次从队首弹出 `(x,y)`，若为终点 `(tx,ty)`，输出 `hit[x][y]` 并结束
    - 否则对四个方向和两种步长：
        - 计算 `(nx,ny)`，若越界则 `break`
        - 若路径至此未遇墙且步长=1：
            - `hit[nx][ny] = hit[x][y]`
            - `push_front((nx,ny))`
        - 否则：
            - `hit[nx][ny] = hit[x][y] + 1`
            - `push_back((nx,ny))`
3. **输出答案**
    - 当终点首次弹出时即为最优答案
4. **复杂度**
    - 时间 O(h·w)，空间 O(h·w)

# C. 钓鱼竞赛 (Competitive Fishing)

**link**：https://codeforces.com/contest/2042/problem/C  
**标签**：贪心、后缀差分、排序

**本质思路**  
从后向前遍历字符串，维护后缀中 Bob 鱼（‘1’）与 Alice 鱼（‘0’）数量差 `sum`。只有当 `sum>0` 时，在这一位置划分一组才能为 Bob
带来正向增益，将所有这样的 `sum` 收集到 `vals` 中，排序后贪心取最大的增益，直到累计增益 ≥ k。

**关键步骤**

1. **后缀累积差分**

    - 初始化 `sum=0`，遍历 `i=n-1…1`：

      ```cpp
      sum += (s[i]=='1' ? 1 : -1);
      if (sum>0) vals.push_back(sum);
      ```

2. **贪心选组**

    - 将 `vals` 排序升序，设 `ans=1`（至少一组）。

    - 反复取出 `vals.back()`：

      ```cpp
      while (k>0 && !vals.empty()) {
        k -= vals.back();
        vals.pop_back();
        ++ans;
      }
      ```

3. **输出结果**

    - 若最终 `k>0` 则输

# P1173. 旅行计划

link: https://www.luogu.com.cn/problem/P1137

**标签**：DAG DP、拓扑排序、最长路径

**本质思路**  
将“只能从西向东”限制视作一个有向无环图（DAG），在 DAG 上对每个节点求最长可达路径长度。

**关键步骤**

1. **建图与初始化**

    - 用邻接表 `g[x]` 存储有向边 `x→y`，并用 `in[y]++` 记录每个节点的入度；
    - 数组 `dp[i]=1`，表示以节点 i 结尾的最长路径至少包含自己。

2. **拓扑排序 (Kahn 算法)**

    - 将所有 `in[i]==0` 的节点入队；
    - 依次弹出队首 `u`，并处理其每条出边 `u→v`。

3. **DP 松弛**

   ```cpp
   dp[v] = max(dp[v], dp[u] + 1);
   if (--in[v] == 0) q.push(v);
   ```

# F. 整除最长链

link: https://codeforces.com/problemset/problem/566/F

**标签**：DAG DP、筛法、数论、最长链

**本质思路**  
最大团即全互整除的元素集合，在整除关系偏序（DAG）上求最长链,变成了DAG on DP

示意图:

       3
     / | \
    v  v  v
    6  9  12
     \  |    \
      vv     v
      18     24
       \     /  \
        v   v    v
         72      48

**关键步骤**

1. **标记出现**
    - `has[i] = true` 表示元素 `i` 在输入集合中出现；
2. **初始化 DP**
    - `dp[i] = 1`，表示单个元素自成长度为 1 的链；
3. **升序枚举 & 埃氏筛**

  ```cpp
   for (int x : a) {
       // 枚举 x 的所有倍数 y
       for (int y = x * 2; y < N; y += x) {
           if (has[y])
               dp[y] = max(dp[y], dp[x] + 1);
       }
   }
  ```

# 陕西2024 C. 换座位

**link**：https://codeforces.com/gym/105257/problem/C

**标签**：拓扑排序、环检测、DAG on DP

**本质思路**  
将每位嘉宾视为节点 $1\ldots n$，每个目标座位视为节点 $1\ldots2n$，连一条有向边 $i\to a_i$。此图由若干「基环树」和「指向空座的树」组成。

- 对于指向空座（编号 $>n$）的树，用拓扑 BFS 剥离「树枝」，维护从根到当前节点的最长链长，更新到各空座。
- 对于剩下的入度 $>0$ 的节点，即在环上，这些环上的嘉宾可以全部就座。  
  整体时间 $O(n)$、空间 $O(n)$。

**关键步骤**

1. **建图与入度统计**
    - 数组 `to[1..n]` 存储每位嘉宾的目标座位
    - `indeg[x]++` 用来统计每个节点的入度

2. **拓扑 BFS 求「最长链」**
    - 所有 `indeg[i]==0`（嘉宾）入队，设 `dist[i]=1`
    - 取出队头 $x$：
        - 若 `to[x]>n`，更新 `seatLen[to[x]] = max(seatLen[to[x]], dist[x])`
        - 否则
            1. `dist[to[x]] = max(dist[to[x]], dist[x]+1)`
            2. `if (--indeg[to[x]]==0)` 则入队

3. **环上节点计数**
    - BFS 结束后，所有 `1≤i≤n` 且 `indeg[i]>0` 的节点均处在环上，记作 `环上人数`

4. **答案汇总**  
   环上人数+各空座的最大链长

# G. 消失的数字

**link**：https://codeforces.com/gym/104921/problem/G

**标签**：进制转换、字符串处理、映射

**本质思路**  
将需要删除所有含 x 的自然数，等价于把数字集合 \{0,1,…,9\} 中去掉 x 后映射到 0~8，共九个“字符”，令原数在此基底下即为一个九进制数；转换为十进制并加
1 即为它在“未消失”序列中的排名。

**关键步骤**

1. **映射数字**  
   将 $n$ 转为字符串 $s$，对每个字符 $d$：
    - 若 $\,d>x$，则替换为字符 $(d-1)$
    - 否则保持不变
2. **九进制求值**  
   从高位到低位遍历映射后的 $s$，维护

3. **加一修正**  
   因为序列包含 $0$，最终排名应为 $\text{ans}+1$。

整体复杂度：$O(|s|)$，空间复杂度：$O(|s|)$

# A. 函数最大子段和

link: https://codeforces.com/problemset/problem/788/A

**标签**：差分、交替符号、最大子段和、Kadane、一维DP

**本质思路**  
将原数组转化为相邻差分并交替赋予正负符号，问题变为在一维数组上求最大子段和，使用Kadane算法在线性时间内完成。

**关键步骤**

构造奇偶下标开头+-差分数组,分别执行一遍Kadane算法

- 时间：$O(n)$
- 空间：$O(n)$

# D. 阿尔卡彭苹果树

link: https://codeforces.com/problemset/problem/1056/D

**标签**：树形 DP、子树统计、排序、Order‐Statistic

**本质思路**  
每个节点要幸福，当且仅当其子树中的叶子数 ≤ 颜色数。将所有节点的“需求”——子树叶子数——统计出来并排序，第 k 小的需求即为使 ≥ k
个节点幸福所需的最少颜色数。

**关键步骤**

1. **树形 DFS 统计叶子数**
    - 从根节点 1 开始递归计算每个节点叶子数量

2. **收集并排序**
    - 将 `leaf[1…n]` 放入数组，升序排序。
3. **直接取第 k 小**
    - 对于每个 k=1…n，输出排序后数组的第 k 项。

**复杂度**

- 时间：一次 DFS O(n) + 排序 O(n log n) = **O(n log n)**
- 空间：O(n)

# C. 粒子反射

**link**：<https://codeforces.com/problemset/problem/1498/C>

**标签**：动态规划、记忆化搜索、三维状态

## 本质思路

将“粒子穿透 + 衰减复制”过程抽象为三维 DP：

- 状态 `dp[i][k][d]` 表示“一个衰减度为 k 的粒子，从第 i 个平面以方向 d（0=左，1=右）射入，最终能产生的粒子总数”。
- 每到一个平面，粒子“自己继续穿透” + “产生一个 k−1 的反向副本”，两者都要计数。
- 边界 k == 1 时，不再复制，`dp[i][1][*] = 1`。

# B. 建筑公司

link: [https://codeforces.com/gym/104417](https://codeforces.com/gym/104417)

**标签**：拓扑排序、贪心、离线扫描

**本质思路**
将每个工程的“需求”当作依赖入度，满足所有需求的工程即入度为0。承接工程会增加员工（状态单调），触发其他工程入度减少，相当于在隐式依赖图上做拓扑排序。

**关键步骤**

1. **收集**：构造 `condition[t]`（工种需求列表）和 `prise[i]`（工程奖励），维护 `in[i]` 为剩余需求数。
2. **离线排序**：对每个 `condition[t]` 按需求人数排序，初始扫描一次减少可满足的入度。
3. **拓扑队列**：所有 `in[i]==0` 入队，循环取出工程，累加奖励后对相关 `condition[t]` 扫描并动态降低 `in[j]`，新 `in[j]==0`
   则入队。
4. **计数**：出队次数即为答案。

**复杂度**
令 $M=\sum m_i+\sum k_i$，$T$ 为工种种类数，总体 $O(M\log M + M\log T + n)$。

# C. Wonderful City

link: [https://codeforces.com/contest/2096/problem/C](https://codeforces.com/contest/2096/problem/C)

**标签**：动态规划、网格、状态压缩、矩阵转置

**本质思路**
将行操作与列操作对水平/垂直冲突的影响分离，分别用「对每行/列做或不做+1操作」的二状态动态规划求最小花费，再相加。

---

## 关键步骤

1. **分治冲突类型**

    * 行操作只影响垂直相邻；列操作只影响水平相邻。
    * 因此可先独立消除垂直冲突，再独立消除水平冲突。

2. **行上 DP 定义**

    * $dp[i][x]$：处理到第 $i$ 行，且对第 $i$ 行执行状态 $x\in\{0,1\}$（0=不加，1=加一）的最小成本。

3. **状态转移**
   对每一行 $i\ge2$，枚举当前 $x$ 与上一行 $y$：

    * 检查所有列 $j$ ：
      $h_{i-1,j} + y \neq h_{i,j} + x$
    * 若所有列都不等，则
      $dp[i][x] = \min(dp[i][x],\; dp[i-1][y] + x\cdot cost_i)$

4. **边界**
   $dp[1][0] = 0,\quad dp[1][1] = cost_1$

5. **求解列冲突**
   将矩阵转置，列操作视为对转置后“行”操作，复用同样的 DP 函数。

6. **合并答案**
   垂直最优 + 水平最优；若任一为无解（∞），输出 -1。

# D. 精彩的灯泡

link: [https://codeforces.com/contest/2096/problem/D](https://codeforces.com/contest/2096/problem/D)

**标签**：不变式、模2、哈希统计、坐标几何

**本质思路**
利用翻转操作对 4 个灯泡的「模 2 奇偶不变性」，分别在竖线 $x=c$ 和对角线 $x+y=c$
上统计开灯数的奇偶，从而唯一定位初始亮灯坐标 $(s,t)$。

---

## 关键步骤

1. **模 2 奇偶不变**

    * 初始只有一个灯亮 → 奇数。每次操作切换 4 盏 → 保持总开灯数奇数。
    * 操作每条竖线/对角线上的灯,每次都是改变两个,奇偶性不变,只与初始是否有灯亮着有关

2. **统计竖线奇偶确定 $s$**

    * 用哈希表 `x_cnt[x]` 记录所有开灯点的横坐标频次。
    * 唯一出现奇数次的横坐标即为宝藏的横坐标 $s$。

3. **统计对角线奇偶确定 $s+t$**

    * 用哈希表 `plus_cnt[x+y]` 记录每个对角线（主对角线族）上开灯数。
    * 唯一奇数次的键值为 $s+t$。

4. **求出 $t$**
   $t = (s+t) - s.$

---

**时间复杂度**：$O(n\log n)$（map 统计）
**空间复杂度**：$O(n)$

# E. Wonderful泰迪熊

link: [https://codeforces.com/contest/2096/problem/E](https://codeforces.com/contest/2096/problem/E)

**标签**：逆序对、贪心、模2不变、位置统计

**本质思路**
将“黑熊(B)”视作 0，“粉熊(P)”视作 1，目标排序变为二进制数组升序。

1. 统计逆序对数 $x$：每个 1 与其右侧所有 0 构成逆序。
2. 统计总 0 数 $a$ 及偶数位 0 数 $b$，目标偶数位放 0 数为 $\lfloor a/2
   floor$，差值为 $d$。
3. 需要 $d$ 次能改偶位的操作(A/C)，每次减 1 个逆序；剩余逆序数 $(x-d)$ 用 B/D 每次减 2。
4. 最终最少操作数 $(x+d)/2$。

# J. 不是一个路径查询问题

**link**：https://codeforces.com/gym/104417/problem/J

**标签**：位运算、掩码枚举、离线连通性、并查集（DSU）、二进制技巧

## 本质思路

利用“AND ≥ V”对路径上每条边的二进制位提出强制性要求，将问题化归为“在若干筛选子图中判断连通性”。

- “AND ≥ V” ⇒ 必须保持 V 中所有 1 位不被“与”掉。
- “AND > V” ⇒ 在 V 的某个 0 位抬成 1 即可。

枚举所有可能的“抬位”掩码（至多 61 种），在每个掩码对应的子图中用并查集合并，离线回答任意一张子图连通性即可。

---

## 关键步骤

1. **掩码构造**

    - 基础掩码 `mask₀ = V`。

    - 对于 V 二进制中每个为 0 的位 `bit`，构造

      ```cpp
      mask = (V & (~((1LL<<(bit+1)) - 1))) | (1LL<<bit);
      ```

      即保留高于 `bit` 的前缀、将该位抬为 1、低位清零。

    - 总共得到 `k = popcount0(V)+1 ≤ 61` 个掩码。

2. **子图建联**

    - 为每个掩码初始化一个并查集 `DSU(n)`。
    - 遍历所有边 `(u,v,w)`：若 `(w & mask) == mask`，则在该掩码子图中合并 `u,v`。
    - 复杂度约 `O(m · k · α(n))`。

3. **离线查询**

    - 对每个询问 `(x,y)`，遍历所有 `k` 个并查集：
        - 若存在某个掩码使得 `find(x)==find(y)`，则输出 **Yes**；否则输出 **No**。
    - 平均只需检查到第一次连通即可，查询复杂度 `O(k·α(n))`。

### 时间复杂度 O((m+q)·logV ·α(n))，空间 O(n·logV)

> **模块化复盘**
>
> 1. 定义“掩码”模板 → 提取必须为 1 的位；
> 2. 枚举抬位 → 生成所有 ≥ V 的最小掩码；
> 3. 在每个掩码子图中用 DSU → 离线判断多次连通性。

# D. 摘苹果

**link**：[https://codeforces.com/contest/2107/problem/D](https://codeforces.com/contest/2107/problem/D)

**标签**：树、直径、DFS/BFS、分治、贪心、字典序

**本质思路**
每次在当前森林中找到“字典序最大的”直径——先取最长路径 $d$，若同长再取端点编号最大的 $(u,v)$——记录 $(d,u,v)$
，并删除整条路径上的节点。删除会将森林分裂成若干子树，对每棵子树重复相同操作。由于任何两条直径必共享至少一个节点，后续直径长度严格下降，因此记录下来的 $(d,u,v)$
序列本身即字典序降序，若需要也可先收集再统一排序。

**关键步骤**

1. **维护组件队列**
   初始将 `1`（或任意节点）入 `Q`，用 `used[]` 标记已删除，`inq[]` 标记已入队。
2. **求直径**
   对每个组件根 `r`：

    * 第一次 BFS/DFS 从 `r` 找到最远节点 `x`（距离最大，遇平距取编号大）
    * 第二次 BFS/DFS 从 `x` 找到最远节点 `y`，此时 $(x,y)$ 即直径两端，长度 `d`
3. **记录答案**
   令 $`u = max(x,y)`, `v = min(x,y)`$，向结果列表 `ans` 添加 $(d,u,v)$
4. **删除路径**
   用 `parent[]` 从 `y` 回溯到 `x`，将沿途所有节点 `used[node] = true`
5. **分裂新组件**
   对删除路径上每个节点的每个邻居 `nb`：
   如果 `!used[nb] && !inq[nb]`，则以 `nb` 为根 BFS 标记整个子树并 `Q.push(nb)`
6. **结束与输出**
   当 `Q` 为空或所有节点已删除时结束。若过程中未保证顺序，可在最后对 `ans` 按降序字典序排序，然后顺序打印所有三元组。

**复杂度分析**

* 时间：O(n√n)（直径长度逐轮下降轮数 = O(√n)，每轮 BFS/DFS 扫描子树）或 O(n log n)（用优先队列优化）
* 空间：O(n)

# E. 异构矩阵

**link**：[https://codeforces.com/contest/12/problem/E](https://codeforces.com/contest/12/problem/E)

**标签**：图论、完全图分解、完美匹配、循环赛程

**本质思路**
将完全图 $K_n$ 的边分解为 $n-1$ 个完美匹配，每个匹配对应一次“圆桌赛程”中的一轮；再用轮次编号（1…$n-1$
）作为矩阵中对称位置的值，主对角置
0。

**关键步骤**

1. **编号与初始化**

    * 顶点用 $0,1,\dots,n-2$ 环形排列，顶点 $n-1$ 固定不动。
    * 构造 $n\times n$ 矩阵，先将所有对角线元素设为 0。

2. **循环配对（共 $n-1$ 轮）**

    * 每轮 $r=0\dots n-2$：

        1. 固定顶点 $n-1$ 与环上顶点 $r$ 配对，赋值 $r+1$。

        2. 对剩余 $i=1\dots \tfrac{n}{2}-1$：

           $u=(r+i)\bmod(n-1),\quad
           v=(r-i+n-1)\bmod(n-1),$

           配对 $(u,v)$，同样赋值 $r+1$。

    * 每轮得到一个完美匹配，确保所有边刚好被分到其中一轮。

3. **输出矩阵**

    * 按行输出，保证对称且主对角为 0。

**复杂度**

* 时间：$\displaystyle O(n^2)$ （填充 $\tfrac{n(n-1)}2$ 条边）
* 空间：$\displaystyle O(n^2)$（矩阵存储）

# P3758 可乐

**link**：[https://www.luogu.com.cn/problem/P3758](https://www.luogu.com.cn/problem/P3758)

**标签**：矩阵快速幂、邻接矩阵、状态转移、图论、建模

**本质思路**
将城市和“自爆”状态统一建模到邻接矩阵中，通过矩阵快速幂在 $t$ 步后统计从初始城市到各状态（包括自爆）的路径数。

**关键步骤**

1. **拓展状态**
   构造大小为 $(n+1)\times(n+1)$ 的邻接矩阵 $A$，其中节点 $0$ 表示“已自爆”状态，节点 $1\ldots n$ 表示各城市。

2. **构造边**

    * 对于每条道路 $u\!-\!v$，设置 $A[u][v]=A[v][u]=1$。
    * 对每个城市 $i$ 设置自环 $A[i][i]=1$ 表示停留不动；设置 $A[i][0]=1$ 表示随时可以自爆；
    * 设置 $A[0][0]=1$ 保证自爆后不可逆。

3. **矩阵快速幂**
   对矩阵 $A$ 进行快速幂运算，计算出 $A^t \bmod 2017$。

4. **汇总答案**
   初始时机器人在城市 $1$，答案即为

   $\sum_{i=0}^{n} (A^t)[1][i]\bmod 2017$

整体复杂度：$O(n^3\log t)$，空间复杂度：$O(n^2)$ 。

# P2587 \[ZJOI2008] 泡泡堂

**link**：[https://www.luogu.com.cn/problem/P2587](https://www.luogu.com.cn/problem/P2587)

**标签**：贪心、排序、双指针、田忌赛马

**简单思路**：

1. 将浙江队和对手的实力数组各自升序排序；
2. 定义函数 `solve(a,b)` 计算我方（`a`）对阵对方（`b`）的得分：
3. 最好情况：`best = solve(a, b)`；
4. 最坏情况：对调双方再解一次，`worst = solve(b, a)`，此时对手得分为 `worst`，浙江队得分就是 `2*n - worst`；
5. 输出 `best` 和 `2*n - worst`。

**复杂度**：

* 总体：$O(n\log n)$时间，$O(n)$ 空间。

# G. 眩晕香蕉

**link**：[https://codeforces.com/contest/2094/problem/G](https://codeforces.com/contest/2094/problem/G)

**标签**：双端队列、模拟、数据结构、数学推导、常数更新

**本质思路**
用一个 `deque` 结合方向标记 `head` 模拟三种持久化操作，维护四个状态变量：

* `s`：正向粗糙度 $f(n)=\sum_{i=1}^n a_i\cdot i$
* `rs`：反向粗糙度 $g(n)=\sum_{i=1}^n a_i\cdot(n+1-i)$
* `sum`：数组元素之和
* `head`：布尔标记，`true` 表示当前 `deque` 正向，`false` 表示逻辑翻转

通过数学推导，可在 $O(1)$ 时间更新这四个量，无需每次遍历或真正翻转数组

**关键步骤**

1. **操作1：循环移位**（把末尾元素移到前端）

    * 令 `an = head ? a.back() : a.front()`

    * 更新正向粗糙度：

      $s \;+=\; sum \;-\; an \times \text{size}$

    * 更新反向粗糙度：

      $rs \;+=\; an \times \text{size} \;-\; sum$

    * 在 `deque` 上根据 `head` 弹出对应端并从另一端插入 `an`

2. **操作2：反转数组**

    * 交换 `s` 与 `rs`
    * 切换方向标记：`head = !head`

3. **操作3：尾部插入 $x$**

    * `sum += x`

    * 更新正向粗糙度：

      $s \;+=\; (\,\text{size}+1)\times x$

    * 更新反向粗糙度：

      $rs \;+=\; sum$

    * 在 `deque` 末端（或逻辑末端）插入 `x`

整体时间复杂度 $O(q)$，空间复杂度 $O(q)$

# F. 和弦交叉

**link**：https://atcoder.jp/contests/abc405/tasks/abc405_f

**标签**：离线算法、Fenwick 树（BIT）、区间统计、排序

**本质思路**  
将“弦与查询弦交叉”的二维判定转换为：

- 统计区间内端点总数 $E$；
- 统计左端在区间外、右端在区间内的弦数 $P$（激活式离线 + BIT）；  
  通过公式 $ext{交叉数} = E - 2P$ 快速得到结果。

**关键步骤**

1. **端点前缀和**
    - 建 `mark[1…2N]`，遍历所有弦 $(a,b)$ 时对 `mark[a]++`,`mark[b]++`。
    - 计算前缀 `pre[i] = mark[1] + … + mark[i]`，区间 $(u,v)$ 内端点数 $E = pre[v-1] - pre[u]$。

2. **离线排序**
    - 将已知弦按左端 $a$ 降序；将所有查询按左端 $u$ 降序。
    - 保证在处理查询 $(u,v)$ 时，所有 $a>u$ 的弦都已“激活”。

3. **Fenwick 树维护**
    - 初始化 BIT 大小为 $2N$。
    - 依次扫描弦数组：当弦 $(a,b)$ 满足 $a>u$ 时，执行 `bit.add(b,1)`，将其右端点“激活”。

4. **查询激活数**
    - 对当前查询 $(u,v)$，用 `P = bit.pre_sum(v-1)` 统计所有激活弦中 `b < v` 的数量。

5. **合并答案**
    - 交叉弦总数 = $E - 2P$。
    - 恢复查询顺序输出。

---

**复杂度分析**

- 时间：$O((M+Q)\log(2N))$
- 空间：$O(N)$

> **技巧总结**：
>
> - 「一侧离线排序 + 另一侧 BIT 前缀和」是处理“区间内外落点”交叉计数的常用套路。
> - 利用端点总数扣除完全包含情况，化简交叉统计。

# C. 网格Mex

**link**：[https://codeforces.com/problemset/problem/2102/C](https://codeforces.com/problemset/problem/2102/C)

**标签**：贪心、BFS、八连通、网格填充

**本质思路**
将数字 0 到 n²−1 按照与中心的“层序”顺序进行填充。数字越小应当离中心越近，这样它们就能出现在更多子网格的最小外接矩形内，从而最大化所有子网格的
MEX 之和。

**关键步骤**

1. **定位中心**

    * 网格使用 0-based，下标范围 \[0,n−1]；中心位置取 `(n−1)/2, (n−1)/2`。

2. **八方向 BFS**

    * 定义 8 个方向偏移：

      ```cpp
      vector<pair<int,int>> dirs = {{0,1},{1,0},{1,1},{-1,0},{-1,1},{0,-1},{1,-1},{-1,-1}};
      ```

    * 使用 `queue<pair<int,int>> q` 从中心入队，标记访问，并赋值 `ans[c][c] = 0`。

    * 每次出队 `(x,y)` 后，依次遍历 8 个方向 `(dx,dy)`：

        * 若 `(nx,ny)` 在边界内且未访问，则标记访问、赋值 `ans[nx][ny] = cur++`、入队。

3. **输出网格**

**复杂度**

* 时间：O(n²)
* 空间：O(n²)

以上方法保证小数越接近中心，它们位于所有包含中心的子网格内，从而确保所有子网格 MEX 总和最大化。

# C. 琼恩·雪诺和她的最爱数字

**link**: [https://codeforces.com/contest/768/problem/C](https://codeforces.com/contest/768/problem/C)

**标签**：桶排序、模拟、异或运算

**本质思路**
当值域比较小,而数组长度很长,快排又过不了的时候,你就应该想到伟大的O(值域)的桶排序! ! !

**关键步骤**

1. **初始化频率桶**

    * 用 `vector<long long> cnt(1 << 10)` 统计初始各强度出现次数。

2. **单次操作模拟**

    * 拷贝 `temp = cnt`。
    * 维护 `bool odd = true`，表示下一待处理的元素位置是“奇数”还是“偶数”。
    * 遍历强度 `i` 从 0 到 1023：

        1. 若 `cnt[i] == 0`，跳过。
        2. 令 `change = cnt[i] / 2`；若 `odd` 且 `cnt[i]` 为奇数，则 `change++`。
        3. 从 `temp[i]` 减去 `change`，加到 `temp[i ^ x]`。
        4. 若 `cnt[i]` 为奇数，翻转 `odd = !odd`。
    * 完成后令 `cnt = temp`。

3. **重复 k 次**

    * 将上述单次模拟循环执行 k 次 (`while (k-- > 0)`)。

4. **输出结果**

    * 遍历 `cnt`，第一个 `>0` 的下标即为最小强度 `min`，最后一个 `>0` 的下标即为最大强度 `max`。

# D. 数三角形

link: https://codeforces.com/problemset/problem/552/D

**标签**：计算几何、组合数学、向量

**本质思路**

- 所有三点组合总数为 $C(n,3)$。
- 退化（三点共线）三角形数通过「每点为基点，按斜率分组」统计，再除以 3 消除重复。
- 答案 = 总三角形数 − 退化三角形数。

**关键步骤**

1. 读入 n 个不同点坐标。

2. 计算总三角形数：
   total = n * (n - 1) * (n - 2) / 6

3. 对每个基点 i：

    - 用哈希表 `cnt` 统计与 i 共线的其他点的归一化方向 `(dx, dy)`，其中

      ```
      dx = (x[j] - x[i]) / g
      dy = (y[j] - y[i]) / g
      g = gcd(|x[j] - x[i]|, |y[j] - y[i]|)
      ```

      统一符号为正方向以保证唯一性：如果 `dx < 0` 或者 `dx == 0 && dy < 0`，则 `(dx, dy) = (-dx, -dy)`。

    - 对每个方向出现次数 `m`，累加退化计数：
      dis += m * (m - 1) / 2 // C(m,2)

4. 因为每个退化三角形会被三个顶点各自统计一次，所以最后做：
   dis = dis / 3

5. 结果输出： result = total - dis

# C. 警察局

**link**：https://codeforces.com/problemset/problem/208/C

**标签**：BFS、DAG on DP、最短路径计数、概率与期望

**本质思路**  
先用无权图上两次 BFS 求出每个节点到文化首都（1）和主首都（n）的最短距离，然后根据“dist1[u]+1+distn[v]==dist1[n]
”筛出恰好出现在最短路径上的有向边构建 DAG。接着在 DAG 上做两次拓扑 DP：正向统计从 1 到 v 的最短路径条数 dp1[v]，反向统计从
v 到 n 的最短路径条数 dpn[v]。最后利用期望线性性：每条有向边 u→v 在随机最短路中被选中的概率为  
$p \;=\;\frac{dp1[u]\times dpn[v]}{dp1[n]}$
将这条边的 p 加到 u 和 v 的期望“安全边数”里，枚举所有节点取最大即为答案。

**关键步骤**

1. **BFS 求距离**
    - 从 1 出发一次得到 `dist1[v]`；
    - 从 n 出发一次得到 `distn[v]`；
    - 最短路长度 $D = dist1[n]$。

2. **构造最短路 DAG**
    - 遍历每条无向边 $\{u,v\}$：
        - 若 `dist1[u]+1+distn[v]==D`，则定向为 `u→v`；
        - 若 `dist1[v]+1+distn[u]==D`，则定向为 `v→u`。

3. **拓扑 DP 统计路径数**
    - 初始化 `dp1[1]=1`，按入度为 0 的顺序遍历 DAG 正向累加 `dp1[v]+=dp1[u]`；
    - 初始化 `dpn[n]=1`，在反向 DAG 上同理累加 `dpn[u]+=dpn[v]`；
    - 总最短路径数为 `tot = dp1[n]`。

4. **计算期望安全边数**
    - 对每条有向边 `u→v`，计算概率 `p = dp1[u]*dpn[v]/tot`，并加到 `E[u]` 和 `E[v]`。

5. **枚举取最大**
    - 结果为 $\max_{1\le x\le n} E[x]$，输出时保留 6 位小数即可通过误差要求。

### C. 魔法五

**link**：[https://codeforces.com/problemset/problem/327/C](https://codeforces.com/problemset/problem/327/C)

**标签**：字符串、快速幂、几何级数、模运算

---

#### 本质思路

* 利用“能被 5 整除只看最后一位是否为 0 或 5”的性质，将每个字符作为“末尾”时的子序列贡献。
* 单次串内第 $i$ 位作为末尾时，左侧任意删除或保留，共有 $2^{i-1}$ 种方式；右侧必须全部删除，贡献 1。
* 原串重复 $k$ 次后，第 $i$ 位在第 $t$ 份中的指数变为 $i-1 + t \times n$，需要对 $t=0\ldots k-1$ 项做等比求和。

---

#### 公式推导

1. **单次串**：第 $i$ 位若可作为末尾，则贡献

   $$
   C_i^{(1)} \;=\; 2^{\,i-1}.
   $$
2. **重复串**：第 $t$ 份的贡献为 $2^{\,i-1 + t\,n}$，故总和

   $$
   \sum_{t=0}^{k-1} 2^{\,i-1 + t\,n}
   = 2^{\,i-1}\;\sum_{t=0}^{k-1}(2^n)^t.
   $$
3. 设公比 $r = 2^n \bmod M$，等比级数和

   $$
   S = \sum_{t=0}^{k-1} r^t
   = \frac{r^k - 1}{r - 1}
   \pmod M.
   $$
4. 因此，第 $i$ 位的整体贡献

   $$
   C_i = 2^{\,i-1}\times S \pmod M.
   $$
5. **答案**：对所有 $s_i\in\{0,5\}$ 的 $C_i$ 累加。

---

#### 关键步骤

1. **快速幂**：实现 $x^y\bmod M$ 的二分幂函数 `bpow(x,y)`。
2. 计算：

    * $r = \text{bpow}(2,n)$
    * $A = \text{bpow}(2, n\cdot k) - 1 \pmod M$
    * $S = A \times (r-1)^{-1} \pmod M$ （费马小定理求逆元）
3. 遍历 $i=0,\dots,n-1$，若 `s[i]=='0'` 或 `s[i]=='5'`，累加

   $$
   \bigl(\text{bpow}(2,i)\times S\bigr)\bmod M.
   $$
4. 输出累加结果。

**时间复杂度** $O(n + \log(nk))$，**空间复杂度** $O(1)$。

# B. 重新排列

link: https://codeforces.com/problemset/problem/67/B

**标签**：隐式DAG、拓扑排序、优先队列、贪心

**本质思路**  
将值为 $i$ 的项视作 DAG 中的节点，初始“入度”由 $b_i$ 给出。每次从所有入度为 0
的节点中选取最小的放入答案（保持字典序），并将其出队相当于删除该节点：对所有尚未放入且满足 $x\ge i+k$ 的节点 $i$ 入度减一，入度为
0 时加入候选集合。

**关键步骤**

1. 初始化数组 `deg[i]=b[i]`，构建小顶堆，将所有 `deg[i]==0` 的节点压入；
2. 当堆非空时：
    - 弹出最小元素 $x$，加入结果 `ans`；
    - 遍历 $i=1$ 到 $n$：若 $x\ge i+k$ 且未放入，则执行 `--deg[i]`，若 `deg[i]==0` 则压入堆；
3. 最终输出 `ans[1..n]`。

复杂度：$O(n^2)$。

# G. 斯拉夫骑自行车

**link**：[https://codeforces.com/contest/1915/problem/G](https://codeforces.com/contest/1915/problem/G)

**标签**：图论、最短路、Dijkstra、状态扩展

**本质思路**
将「城市编号」和「当前持有自行车的迟缓因子」作为联合状态，用扩展后的 Dijkstra 在状态图上求最短时间。

**关键步骤**

1. **状态定义**
   定义
   $\mathrm{dist}[u][k]$
   为到达城市 $u$ 且持有迟缓因子为 $k$ 的自行车时的最短时间。

2. **初始化**

    * 将所有 $\mathrm{dist}[u][k]$ 置为 $\infty$，
    * 令 $\mathrm{dist}[1][s_1]=0$，并把状态 $(1,\,s_1)$ 入最小堆。

3. **状态转移**
   每次从堆中弹出当前最小的 $\mathrm{dist}[u][k]$，若已标记访问则跳过；否则遍历所有邻边 $(u\to v,\,w)$：

    * 计算可选的新迟缓因子

      $$
      k'=\min\bigl(k,\;s_v\bigr)
      $$
    * 骑行代价

      $$
      \Delta = w \times k
      $$
    * 松弛条件

      $$
      \text{如果}\;\mathrm{dist}[v][k']>\mathrm{dist}[u][k]+\Delta
      \;\text{则更新}\;
      \mathrm{dist}[v][k']=\mathrm{dist}[u][k]+\Delta
      $$

      并将 $(v,\,k')$ 推入堆。

4. **答案提取**
   最终在城市 $n$ 所有可能的迟缓因子上取最小值：

   $$
   \min_{1\le k\le S_{\max}}\;\mathrm{dist}[n][k]
   $$

---

**复杂度分析**

* 状态数 $O(n\times S)$，其中 $S_{\max}\le1000$
* 边数 $m\le1000$
* Dijkstra 时间约为 $O(mS\log(nS))$，空间 $O(nS)$
  均在题目约束下可行。

# P1273 有线电视网

link: [https://www.luogu.com.cn/problem/P1273](https://www.luogu.com.cn/problem/P1273)

**标签**：树形DP、01背包、DFS

**本质思路**
把每棵分支视为「选或不选」两种状态：选则统一扣一次整个分支费用，不选则保留原 `dp`；在叶子处按体积为 1 的 0/1 背包插包。使用一维数组
`dp[i]` 记录恰选 \$i\$ 个用户时的最大净收益。

**关键步骤**

1. **DP 定义**
   一维数组 `dp[0…m]`，
   $dp[i] = \max\{\text{选 }i\text{ 个用户的净收益}\}.$

2. **初始化**
   `dp[0] = 0`，`dp[i] = -inf`

3. **DFS 合并子树**
   对节点 $x$ 的每个子节点 $y$（边费 $c$），依次执行：

    * 备份：`tot = dp`
    * 扣费：`for i = 0…m if dp[i] > -∞ then dp[i] -= c`
    * 递归：`dfs(y)`
    * 恢复：`for i = 0…m dp[i] = max(dp[i], tot[i])`

4. **叶子插包**
   对叶子（支付 $w$）01背包：
   `for i = m…1 if dp[i-1] > -∞ then dp[i] = max(dp[i], dp[i-1] + w)`

5. **取答案**
   DFS 完成后，在根节点的 `dp` 中，从 $m$ 向下找到第一个
   $dp[i] \ge 0$
   的 $i$ 即为最大可选用户数。

# P2585 三色二叉树

link: [https://www.luogu.com.cn/problem/P2585](https://www.luogu.com.cn/problem/P2585)

**标签**：树形DP、二叉树、状态枚举

**本质思路**  通过递归把前序字符串解析成二叉树，然后在树上做后序DP，对每个节点和每种颜色状态分别记录子树内最多与最少绿色数，最后在根节点三种颜色中取最优。

**关键步骤**

1. **建树**
   前序序列含义：

    * `0`：叶节点
    * `1S`：单子树，用 `1` 标记，接下来解析一个子树
    * `2S1S2`：双子树，用 `2` 标记，接着解析左右子树
      维护指针 `i` 和下一个索引 `nxt`，递归读取字符并把新节点的下标加入父 `child` 列表。

2. **状态定义**
   对每个节点 `u`，及颜色 `c∈{0,1,2}`（0=红,1=绿,2=蓝），维护：

    * `dp_max[u][c]`：在 `u` 子树里给 `u` 涂色 `c` 时的**最多**绿色数
    * `dp_min[u][c]`：在 `u` 子树里给 `u` 涂色 `c` 时的**最少**绿色数
      自身是否绿色通过 `(c==1)?1:0` 计入。

3. **后序DP**

   ```text
   dfs(u):
     if u 无子：
       dp_max[u][c]=dp_min[u][c]=(c==1)
       return
     if u 只有一个子 v：
       dfs(v)
       dp_max[u][c]=(c==1)+max{dp_max[v][d] | d≠c}
       dp_min[u][c]=(c==1)+min{dp_min[v][d] | d≠c}
       return
     // 两个子 v1,v2：
     dfs(v1), dfs(v2)
     dp_max[u][c]=(c==1)+max{dp_max[v1][d1]+dp_max[v2][d2] | d1≠c,d2≠c,d1≠d2}
     dp_min[u][c]=(c==1)+min{dp_min[v1][d1]+dp_min[v2][d2] | 同上}
   ```

4. **答案**
   在根节点 `1`，取：

    * 最多绿色 = `max(dp_max[1][0], dp_max[1][1], dp_max[1][2])`
    * 最少绿色 = `min(dp_min[1][0], dp_min[1][1], dp_min[1][2])`

---

**时间复杂度**：O(n)；**空间复杂度**：O(n)

# P3047. 距离K内树上权值和

link: [https://www.luogu.com.cn/problem/P3047](https://www.luogu.com.cn/problem/P3047)

**标签**：树形 DP、换根 DP、DFS、二维状态

**本质思路**
对每个节点统计距离它恰好 d 的节点权重和，分为“子树内”（down）和“树外”（up）两部分，用两次 DFS（下 DP + 重根 DP）完成，最终合并得到距离小于等于
K 的所有贡献。

**关键步骤**

1. **下 DP（dfs1）**

    * 定义 `down[x][d]`：节点 x 子树内恰好距离 d 的节点权重和。
    * 初始化：`down[x][0] = w[x]`。
    * 递推：遍历子节点 y，对 1 <= d <= K，
      `down[x][d] += down[y][d-1]`

2. **重根 DP（dfs2）**

    * 定义 `up[x][d]`：不在 x 子树内、恰好距离 d 的节点权重和。
    * 根设 `up[r][d] = 0`（任选根 r）。
    * 距离 1：
      `up[y][1] = w[x]`
    * 距离 d >= 2：
      `up[y][d] = up[x][d-1] + (down[x][d-1] - down[y][d-2])`
    * 解释：第一项是“先上到 x 再向上走 d-1 步”，第二项是“先上到 x 再向下走 d-1 步，但剔除进入 y 子树的部分”。

3. **合并答案**
   对每个节点 x 计算
   `M[x] = sum_{d=0..K}(down[x][d] + up[x][d])`

**时间复杂度**：O(N*K)；**空间复杂度**：O(N*K)。

### C1. Hacking Numbers (Easy Version)

**link**：[https://codeforces.com/contest/2042/problem/C1](https://codeforces.com/contest/2042/problem/C1)

**标签**：交互、数位和、不变式、二分收敛

**本质思路**

1. **两次 `digit` 收敛**：任意初始 $x\in[1,10^9]$

    * 第一次 `digit` 后 $x\in[1,81]$
    * 第二次 `digit` 后 $x\in[1,16]$
2. **二分式 `add -i`**：对 $i=8,4,2,1$ 依次尝试 `add -i`，将区间对半缩小，最终收敛到 1
3. **加偏移**：`add n-1` 把 1 变为目标 $n$

---

### C2. Hacking Numbers (Medium Version)

**link**：[https://codeforces.com/contest/2042/problem/C2](https://codeforces.com/contest/2042/problem/C2)

**标签**：交互、数论、数字根、不变式

**本质思路**

1. `mul 9`：将任意 $x$ 映射到 9 的倍数
2. `digit`：求数位和，$x\to9$
3. `digit`：再次求数位和，不变仍为 $9$
4. `add n-9`：把 9 调整到目标 $n$

---

### C3. Hacking Numbers (Hard Version)

**link**：[https://codeforces.com/contest/2042/problem/C3](https://codeforces.com/contest/2042/problem/C3)
**标签**：交互、数论、数字根、9 补码、不变式

**本质思路**

1. `mul 999999999`（$10^9-1$）：对任意 $x\le10^9$，有

   $$
   S\bigl((10^9-1)x\bigr) = 81
   $$

   通过十进制“9 的补码”拆分，保证数位和恒为 $9\times9=81$。
2. `digit`：再次求数位和，不变仍为 $81$
3. **条件执行**：若 $n\neq81$，执行 `add n-81`；若 $n=81$，可省略该步

**命令数**：

* $n=81$ 时 $f(81)=2$；
* 其他 $n$ 时 $f(n)=3$。

# D. D/D/D

**link**：[https://codeforces.com/contest/1025/problem/D](https://codeforces.com/contest/1025/problem/D)
**标签**：图论、BFS、双状态、子集和、奇偶性

**本质思路**
将“恰走 $k$ 步”归结为“最短距离＋奇偶校验”。

* 预处理每个顶点到 1 的最短偶数步数 $\mathrm{dist}[i][0]$ 和最短奇数步数 $\mathrm{dist}[i][1]$。
* 计算多重集 $A$ 的总和 $S=\sum_i a_i$ 及最小奇数票 $\mathrm{minOdd}=\min\{a_i\mid a_i\bmod2=1\}$。

**关键步骤**

1. **读入并统计**

    * $S=\sum a_i$。
    * 如果存在奇数，则 $\mathrm{minOdd}=\min\{a_i\mid a_i\%2=1\}$，否则 $\mathrm{minOdd}=\infty$。
2. **双状态 BFS**

    * 从状态 $(1,0)$ 入队：表示在顶点 1，已走步数模 2 为 0。
    * 每沿一条边扩展，步数加 1 并翻转模 2 值，更新 $\mathrm{dist}[v][p\oplus1]$。
3. **可达性判定**

    * 令 $p = S\bmod2$，$q=1-p$。
    * 顶点 $i$ 可达当且仅当

        * $\mathrm{dist}[i][p]\le S$，或
        * $\mathrm{dist}[i][q]\le S-\mathrm{minOdd}$。

**复杂度**

* 时间：$O(n+m+\ell)$
* 空间：$O(n+m+\ell)$

# F. 割树算权

link: https://atcoder.jp/contests/abc406/tasks/abc406_f

**标签**：树分解、欧拉序、树状数组、区间查询、区间更新

**题目简述**  
给定一棵有 \(N\) 个顶点的树（顶点编号 \(1\) 到 \(N\)），每条边编号 \(1\) 到 \(N-1\)。初始时所有顶点的权值均为 1。需要在线处理
\(Q\) 个查询，查询包括：

- `1 x w`：将顶点 \(x\) 的权值增加 \(w\)。
- `2 y`：若删除第 \(y\) 条边，则树分为两个子树，分别计算它们的顶点权值之和，输出两者之差的绝对值。

**本质思路**  
通过 DFS
扁平化（欧拉序）将树上子树映射到一维数组的连续区间，结合树状数组维护点权并支持区间求和与点更新，使每次操作在 $O(\log N)$
内完成。

**关键步骤**

1. **DFS 扁平化**  
   从根节点 1 开始 DFS，记录每个节点的进入时间 $\mathrm{tin}[u]$ 与退出时间 $\mathrm{tout}[u]$，使子树 $u$
   对应一维区间 $[\mathrm{tin}[u],\,\mathrm{tout}[u]]$。

2. **树状数组初始化**  
   构造长度为 $N$ 的树状数组 BIT，将所有节点初始权值设为 1：遍历 $i=1\dots N$ 执行 `bit.add(tin[i], 1)`，并维护总权值
   `total = N`。

3. **处理类型 1 查询**  
   `1 x w`：在 $\mathrm{tin}[x]$ 位置执行 `bit.add(tin[x], w)`，并更新 `total += w`。

4. **处理类型 2 查询**  
   `2 y`：考虑删除第 $y$ 条边 $(u,v)$，取深度更大的端点记为 $c$，计算子树权值  
   $$S = \mathrm{bit.sum}(\mathrm{tin}[c],\,\mathrm{tout}[c]),$$  
   另一部分权值为 $\mathrm{total} - S$，答案为  
   $$\bigl|\,( \mathrm{total}-S ) - S \bigr| \;=\; \bigl|\,\mathrm{total} - 2S\,\bigr|.$$

5. **复杂度分析**  
   预处理 DFS 序 $O(N)$，每次 BIT 更新/查询 $O(\log N)$，总体时间复杂度 $O((N+Q)\log N)$，空间复杂度 $O(N)$。

# C. 波浪

link: https://atcoder.jp/contests/abc406/tasks/abc406_c

**标签**：字符串化、跑长压缩（RLE）、组合计数

**题目简述**：给定一个长度为 N 的排列 P = (P₁, P₂, …, Pₙ)，统计它的 所有 连续子数组中，满足“tilde
形”（先严格上升一段，再严格下降一段，再严格上升一段；且总长度 ≥ 4）的子数组数量。

**本质思路**

1. 把原排列 $P$ 转成符号串

   $$
   S_i =
   \begin{cases}
   '<', & P_i < P_{i+1},\\
   '>', & P_i > P_{i+1}.
   \end{cases}
   $$
2. 对 $S$ 做**跑长压缩**，得序列 $\{(c_1,\ell_1),(c_2,\ell_2),\dots\}$，其中每对 $(c_i,\ell_i)$ 表示字符 $c_i$
   连续出现了 $\ell_i$ 次。
3. 枚举压缩后每个中间的 $'>'$ 段 $(c_i='>',\,\ell_i=b)$：

    * 左侧必是 $( '<',\,a )$，右侧必是 $( '<',\,c )$。
    * 子串形状为 `<^x >^b <^y`，其中 $1\le x\le a$、$1\le y\le c$，共有 $a\times c$ 种选择。
4. 把所有 $a\times c$ 累加即得答案。

# E. Popcount Sum 3

link: [https://atcoder.jp/contests/abc406/tasks/abc406\_e](https://atcoder.jp/contests/abc406/tasks/abc406_e)

**标签**：组合数学、二进制 DP、预计算

**题目简述**
给定正整数$N$和$K$，求所有满足 1≤x≤N 且 popcount(x)=K 的整数之和，结果对 998244353 取模。共有 T 组测试。

**本质思路**

1. **预计算“低位”表**

    * 定义
      $c[i][j]=|\{0≤x<2^i:\mathrm{popcount}(x)=j\}|$，
      $s[i][j]=\sum_{0≤x<2^i,\mathrm{popcount}(x)=j}x$。
    * 用 DP 递推：每次在第$i$位插 0/1，有

        * $c[i+1][j]+=c[i][j],\;s[i+1][j]+=s[i][j]$
        * $c[i+1][j+1]+=c[i][j],\;s[i+1][j+1]+=s[i][j]+2^i·c[i][j]$
    * 预计算时间$O(60^2)$，得到所有$0≤j≤i≤60$的值。

2. **高位扫描“断开”与“跟随”**

    * 将$N$的二进制展开为 bit$[i]$($0≤i<60$)。
    * 维护三个值：

        * `cur` = 已跟随置 1 的位数；
        * `offset` = 这些已置 1 的高位前缀的数值和；
        * `ans` = 当前累加的答案。
    * 从最高位$i=59$到 0 扫描：

        * 若 bit$[i]$=1，设 need=K−cur，则

            1. **断开**：将此位设 0，在低$i$位凑出 need 个 1，贡献 =
               $s[i][need]+offset×c[i][need]$。
            2. **跟随**：保留该位为 1，更新`cur+=1`，`offset+=2^i`。

3. **尾声加上 N 本身**
   扫完所有位后，若`cur==K`，则再加上`offset`（此时等于 N）。

**复杂度**

* 预计算：$O(60^2)$；
* 每组查询：$O(60)$；
* 总计：$O(60^2+T×60)$，非常高效。

# D. GCD秩集合

link: [https://codeforces.com/problemset/problem/477/B](https://codeforces.com/problemset/problem/477/B)

**标签**：数论、构造、gcd、平移技巧

**题目简述**：
给定正整数 $n, k$，需要从区间 $[1, m]$ 中选出 $n$ 个集合，每个集合恰好包含 4 个两两满足 $\gcd = k$
的不同正数，且集合间无公共元素。要求最小化 $m$，并输出一种可行方案。

**本质思路**：

* **化归**：对每个数除以 $k$，化为两两互素（秩 1）的问题。
* **构造秩 1 模板**：模板 $\{6a+1,\,6a+2,\,6a+3,\,6a+5\}$，内部元素两两互素。
* **平移生成**：令 $a=0,1,\dots,n-1$，平移步长 6，得到 $n$ 个不重叠集合。
* **复原**：将模板元素再乘回 $k$，恢复到秩 $k$。
* **最小化 $m$**：最后一个集合的最大元素为 $(6(n-1)+5)\times k$，即最小可行的 $m$。

**关键步骤**：

1. 计算最小 $m = (6n - 1)\times k$。
2. 对 $i=0$ 到 $n-1$，输出集合

   $$
   (6i+1)k,\; (6i+2)k,\; (6i+3)k,\; (6i+5)k
   $$
3. 保证每组内两两 $\gcd = k$，且集合间无交集。

**复杂度分析**：

* 时间复杂度：$O(n)$，只需一次线性遍历。
* 空间复杂度：$O(1)$，常数额外空间。

**结论**：
要构造 $n$ 个秩为 $k$ 的 4 元集合，可先除 $k$ 化为秩 1，再用模板 $\{6a+1,6a+2,6a+3,6a+5\}$ 平移，最后乘回 $k$
。最小 $m=(6n-1)\times k$。

# D. 彭奇克与沙漠兔

**link**：[https://codeforces.com/contest/2031/problem/D](https://codeforces.com/contest/2031/problem/D)

**标签**：前缀最大，后缀最小，贪心，构造

---

## 题目简述

给定长度为 $n$ 的数组 $a[1..n]$，定义兔子可从下标 $i$ 跳到 $j$ 当且仅当：

* 若 $j<i$，则 $a_j > a_i$；
* 若 $j>i$，则 $a_j < a_i$。
  对于每个起点 $i$，求兔子能到达的所有位置中，树的最大高度。

---

## 本质思路

利用「前缀最大」与「后缀最小」拆分可达性边界：

* 定义
  $p_i = \max(a_1,\dots,a_i),\quad s_{i} = \min(a_i,\dots,a_n).$
* 当 $p_i > s_{i+1}$ 时，前缀 $[1,i]$ 与后缀 $[i+1,n]$ 之间可双向连通，故从 $i$ 出发能到达的最大高度与从 $i+1$ 出发相同；
* 否则，前后段互不连通，从 $i$ 只能在 $[1,i]$ 内活动，其最大高度即 $p_i$。

整体仅需一次从左到右计算前缀最大和一次从右到左计算后缀最小，再一次线性扫描确定答案，实现 $O(n)$。

---

## 关键步骤

1. **计算前缀最大**
   $p_0 = -\infty,\quad p_i = \max(p_{i-1},\,a_i).$
2. **计算后缀最小**
   $s_{n+1} = +\infty,\quad s_i = \min(a_i,\,s_{i+1}).$
3. **DP 赋值**

    * 令 $\mathrm{ans}[n] = p_n$。
    * 从 $i=n-1$ 到 $1$ 递推：

      ```
      if (p_i > s_{i+1})
          ans[i] = ans[i+1];
      else
          ans[i] = p_i;
      ```
4. **输出** $\mathrm{ans}[1..n]$。

---

**复杂度**：时间 $O(n)$，空间 $O(n)$。

# D. 塔尼娅和密码

**链接**：https://codeforces.com/contest/508/problem/D

**标签**：图论 · 欧拉路径 · De Bruijn 图 · Hierholzer 算法

**题意**：
 给定所有长度为 3 的连续子串（可能有重复），共 n 个，要求还原出原始密码（长度为 n+2），或者判断不存在这样一个密码。

------

## 核心思路

1. **建图（De Bruijn 图）**
   - 取每个子串 `s = c0 c1 c2` 的前两个字符 `u = c0 c1` 和后两个字符 `v = c1 c2`。
   - 把所有长度为 2 的字符串作为图的顶点。对于每个子串，在 u → v 之间加一条有向边，同时记录 out[u]++ 和 in[v]++。
2. **判断是否存在欧拉路径**
   - 统计每个顶点的出度 out 和入度 in，计算差值 Δ = out–in：
     - 至多一个顶点 Δ = 1（起点），
     - 至多一个顶点 Δ = –1（终点），
     - 其余顶点 Δ = 0。
   - 检查所有有边的顶点是否在同一个弱连通块中（用一次 DFS/BFS 即可）。
   - 如果不满足上面条件，就输出 "NO"。
3. **Hierholzer 算法构造路径**
   - 选一个起点：优先选 Δ = 1 的顶点，否则任选一个有边的顶点。
   - 用栈 `stk` 来模拟：
     - 将起点压入 `stk`；
     - 当 `stk` 不为空时：
       1. 看栈顶 `u = stk.back()` 是否有剩余出边；
       2. 如果有，取出一条边 `u → v` 并从图中删除，压入 `v`；
       3. 如果没有，弹出 `u` 并将其加入结果 `path`。
   - 最后 `path` 存储的是逆序的顶点序列。
4. **恢复密码字符串**
   - 将 `path` 反转为 `v0, v1, …, v(n+1)`。
   - 输出 `v0`（两个字符），然后依次输出每个 `vi` 的第二个字符，即可得到长度 n+2 的密码。

------

## 小贴士

- **De Bruijn 图**：一种把重叠子串转换为图模型的方法，这里 k=3 时图的 阶 为 2。
- **Hierholzer 算法**：在线性时间内找到欧拉路径／回路的经典做法。

------

**时间复杂度**：构建图、遍历边、DFS 都在 O(n) 左右；由于使用 `map`，实际会加上 O(log n) 的因子。

**空间复杂度**：O(n)。

# G. 探险

**link**：https://codeforces.com/gym/105911/problem/G  
**标签**：有向图、动态规划、二分查找、乘积截断  

**题目简述**：  
给定 $n$ 个洞穴和 $m$ 条单向带权边，初始体力为 $x$，每走一条边 $(u\to v)$ 难度为 $d$ 时，体力变为 $\lfloor x/d\rfloor$。当体力降为 $0$ 时停止。对每个查询 $(p,x)$，求从节点 $p$ 出发使体力首次为 $0$ 的最少边数。

**本质考点**：  
- **建模**：将除法操作反向为乘法累积；  
- **优化**：由于每次除数最小为 $2$，最多约 $\log_2 10^9\approx30$ 步归零；  
- **结构识别**：在有向图上做步数分层的最大乘积 DP。

**本质思路**：  
- 反向考虑：恰走 $t$ 步时能累积最大难度乘积 $P$，若 $P > x$ 则 $\lfloor x/P\rfloor = 0$。  
- 上界步数取安全裕量 $T = 35$。  
- 预计算所有节点、所有步数的最大乘积表 $dp[u][t]$，再对每个查询二分步数。

**关键步骤**：  

1. **确定最大步数 $T$**：  
   - 每步至少除以 $2$，最大体力 $10^9$ 需 $\le30$ 步，取 $T = 35$。  
2. **DP 定义**：  
   $$dp[u][t] = \max_{(u\to v,\,d)}\Bigl(\min(\mathrm{INF},\;dp[v][t-1]\times d)\Bigr).$$  
   - 初始：$dp[*][0]=1$。  
3. **DP 预处理**：  
   - 枚举 $t=1\ldots T$，在所有 $m$ 条边上做一次转移：  
     $$O(T\times m).$$  
4. **二分查询**：  
   - 对于查询 $(p,x)$，在 $t\in[1,T]$ 上二分第一个满足 $dp[p][t] > x$，复杂度 $O(\log T)$。  

**复杂度**：  
- 时间：$$O\bigl(T(n+m) + Q\log T\bigr)\approx O\bigl(35(n+m) + Q\cdot6\bigr).$$  
- 空间：$$O(n\times T).$$

# 2071C. 村上蠢鼠

link: https://codeforces.com/contest/2071/problem/C

**标签**: 树、DFS、贪心

**题目简述**
 给定一棵有 $n$ 个顶点的树，起始顶点 $st$ 和陷阱顶点 $en$。需要找出一个长度为 $n$ 的排列 $p$，使得一只老鼠从 $st$ 出发，每一步按照排列中指定的顶点移动（若已在该顶点则停留），最终必然停在 $en$。

**本质思路**
 将树以 $en$ 为根，计算每个节点到 $en$ 的深度 $dep[i]$。然后按深度从大到小依次“放”奶酪（输出节点编号），保证老鼠在每一步的深度不会增大，最终必然被“逼”回到深度 0 的 $en$。

**关键步骤**

1. - **根化 + 深度计算**  
     - 以 $en$ 为根，做一次 DFS 或 BFS，得到数组 $dep[1\ldots n]$，其中  
       $dep[v] = \mathrm{dist}(en,\,v)$
2. **深度分桶**
   - 准备一个二维数组或向量 `bucket`，长度 $\max(dep)+1$，遍历所有节点 $i$，将 $i$ 放入 `bucket[dep[i]]`。
3. **倒序输出排列**
   - 从最大深度 $D=\max(dep)$ 到 0，依次遍历 `bucket[d]` 中的所有节点，将它们追加到排列 $p$ 末尾。
4. **贪心正确性**
   - 老鼠每次看到奶酪都会沿最短路径前往对应节点，该路径深度单调不增，因此不会“跑远”。最终必在深度 0（即 $en$）结束。

**复杂度分析**

- 时间复杂度：DFS/BFS $O(n)$ + 分桶与倒序遍历 $O(n)$，总 $O(n)$。
- 空间复杂度：$O(n)$（邻接表 + 深度数组 + 分桶）。

# P8774 爬树的甲壳虫

link: https://www.luogu.com.cn/problem/P8774

**标签**：期望DP、线性方程、模逆运算

**题目简述**  
甲壳虫从高度 0（树根）开始，想爬到高度 $n$（树顶）。当它尝试从高度 $i-1$ 到 $i$ 时，  
- 以概率 $P_i=\dfrac{x_i}{y_i}$ 失败并回到根，  
- 以概率 $1-P_i$ 成功到达 $i$。  
每次尝试花费 1 单位时间。求爬到顶点的期望时间 $E$，对 $M=998244353$ 取模。

---

## 本质思路  
- 令  
  $$f[i]=\text{从根爬到高度 }i\text{ 的期望时间},\quad f[0]=0.$$
- 对每个 $1\le i\le n$，写出状态方程：  
  $$
  f[i]
    =(1-P_i)+f[i-1]
    +P_i\bigl(f[i]+1\bigr).
  $$
- 移项得：  
  $$
  f[i]\,(1-P_i)=f[i-1]+1
    \quad\Longrightarrow\quad
    f[i]=\frac{f[i-1]+1}{1-P_i}.
  $$
- 使用费马小定理+快速幂计算逆元

---

## 关键步骤

1. **初始化**  
   设 $f[0]=0$。

2. **预处理概率**  
   对每个 $i$ 读取 $(x_i,y_i)$，  
   计算 $\mathrm{den}^{-1}=(y_i - x_i)^{-1}\bmod M$。

3. **正向 DP**  
   对 $i=1\ldots n$：  
   $$
   f[i]
     =\bigl(f[i-1]+1\bigr)\times y_i\times(y_i - x_i)^{-1}
     \;\bmod M.
   $$

4. **输出**  
   打印 $f[n]$。

---

**复杂度**  

- 时间：$O(n\log M)$；  
- 空间：$O(n)$（可滚动为 $O(1)$）。

# K. 复合函数

link: [https://codeforces.com/gym/103941/problem/K](https://codeforces.com/gym/103941/problem/K)

**标签**: 功能图、基环树、整除判断、离线分桶、二分查找

**题目简述**
给定一个函数 $f: I_n \to I_n$，其中

$$
  I_n = \{\,1,2,\dots,n\},
$$

且图中每个节点的出度均为 1。还有 $q$ 组查询 $(a,b)$。
询问满足

$$
  f^{\,a}(x) \;=\; f^{\,b}(x)
$$

的节点 $x$ 的个数，其中 $a,b \le 10^{18}$。

---

## 本质思路

将函数图分解成若干棵 **基环树**：每棵基环树由

* 一个长度为 $c$ 的**环**，以及
* 环上每个节点向外挂出的若干棵倒挂树（树根在环上）。

对于一个节点 $x$，我们要预处理以下两个值：

1. $c_x$：节点 $x$ 所在的环的长度；
2. $d_x$：节点 $x$ 到它所在环上最近节点的距离（深度）。

令

$$
  \ell \;=\; \min(a,b), 
  \qquad 
  \Delta \;=\; |\,a - b\,|.
$$

那么

$$
  f^{\,a}(x) \;=\; f^{\,b}(x)
  \quad\Longleftrightarrow\quad
  \underbrace{\ell \;\ge\; d_x}_{\text{已进入环}}
  \quad\wedge\quad
  \underbrace{\Delta \bmod c_x \;=\; 0}_{\text{环上同余}}
  \,.
$$

* 条件 $\ell \ge d_x$ 保证“从 $x$ 出发，走 $\ell$ 步时至少已经进到环里”。
* 条件 $\Delta \bmod c_x = 0$ 保证“在环里多走 $\Delta$ 步时，仍然停在环上同一个位置”。

如果 $a = b$，那么 $\Delta = 0$ 且 $\ell = a = b$。此时对于任意节点 $x$，都成立

$$
  f^{\,a}(x) \;=\; f^{\,b}(x),
$$

答案直接等于 $n$。

---

## 关键步骤

### 1. 找环 + 标深度

1. 使用“拓扑式 DFS/栈”或“白灰黑染色法”在出度为 1 的图里定位每个新环。
2. 对环上节点标记深度 $d_x = 0$，环长度为 $c$；然后从环上的所有节点同时做一轮 BFS（沿倒挂树的入边向外走），将倒挂树中各节点的深度设置为它指向的父节点深度 +1。

这样就能得到对每个 $x\in I_n$：

$$
  (\,c_x,\;d_x\,).
$$

### 2. 离线分桶

把所有节点按“其环长”为键分到不同桶中：

$$
  \text{bucket}[\,c\,]
  \;=\;\{\;d_x \mid c_x = c,\;x\in I_n\;\}.
$$

然后对每个桶内的深度序列进行升序排序，后续可以用 `upper_bound` 快速查询“有多少深度 $\le \ell$”。

### 3. 回答查询

* **若 $a = b$**，直接输出 $n$。
* **否则**，计算

  $$
  \ell \;=\;\min(a,b), 
    \quad 
    \Delta \;=\;\bigl|\,a - b\,\bigr|.
  $$

  枚举 $\Delta$ 所有的正因子 $c \le n$。若 `bucket[c]` 存在，则对该桶中排序后的深度数组做

  $$
  \bigl|\{\,d \in \text{bucket}[c]\mid d\le \ell\}\bigr|
    \;=\;
    \text{upper\_bound}\bigl(\text{bucket}[c],\,\ell\bigr)\;-\;\text{begin}(\text{bucket}[c]).
  $$

  把这些计数累加，即得到本次查询的答案。

> **注意**：枚举因子时只需枚举 $\Delta$ 的所有正因子并筛选出 $\le n$。因为 $\Delta\le 10^{18}$ 最坏也只需枚举到 $\min(\sqrt{\Delta},\,n)$，总体 $O(\sqrt{n})$。

---

## 整体复杂度

1. **预处理**

   * 找环 + 深度标记：$O(n)$。
   * 离线分桶并排序：$\displaystyle \sum_{c}|\text{bucket}[c]|\log|\text{bucket}[c]|\;\le\;O(n\log n)$。
     因此预处理总计 $O(n\log n)$。

2. **每次查询**

   * 枚举 $\Delta$ 的正因子：最坏 $O(\sqrt{n})$。
   * 对其中每个合法的环长 $c$ 做一次二分：$O(\log n)$。
     故单次查询约为 $O(\sqrt{n}\,\log n)$。
     由于 $q \le 10^5$，整体可在 $O\bigl(q\,\sqrt{n}\,\log n\bigr)$ 内完成。

---

$$
\boxed{
  \text{预处理}\;O\bigl(n\log n\bigr), 
  \quad
  \text{单次查询}\;O\bigl(\sqrt{n}\,\log n\bigr).
}
$$

# C. gcd替换

link: https://codeforces.com/contest/1028/problem/C

**标签**: 数论、gcd、动态规划

**题目简述**
 给定长度为 $n$ 的正整数数组 $a$，允许反复进行如下操作直到所有元素相等：

> 选 $i \neq j$，令 $a_i := \gcd(a_i,,a_j)$。
>  求最少操作次数使得数组所有元素相同。

------

## 本质思路

1. 任意 $\gcd$ 操作只会让当前元素收敛到原始值的一个因子，最后所有元素必然收敛到数组的全局 $\gcd$ 记为 $g$.
2. 因此先算出 $g = \gcd(a_1, a_2, \dots, a_n)$，再归一化 $b_i = a_i / g$，目标变为“让所有 $b_i$ 都变为 1”。
3. 若已有元素 $b_i = 1$（此时对应的 $a_i = g$），那么剩下的每个 $b_j > 1$ 直接和这个 1 做一次 $\gcd(b_j, 1) = 1$ 操作就能降到 1，总操作数 = $n - (\text{已有 }b_i = 1\text{ 的个数})$.
4. 若一开始没有任何 $b_i = 1$，则需要先“将某个元素从 $b_i > 1$ 一步步操作变成 1”——这部分用动态规划求最少步数 $\mathrm{dp}[1]$.
5. 再加上将其余 $n - 1$ 个元素各做一次 $\gcd(b_j, 1) = 1$ 的操作，总答案 = $(\mathrm{dp}[1] - 1) + (n - 1)$.
   - 这里 $\mathrm{dp}[1] - 1$ 的 “−1” 是因为最后一步变到 1 后，不需要再向其他元素传播。

------

## 详细步骤

1. **计算全局 $g$ 并归一化**

   - 用一次遍历累积 $g = \gcd(a_1, a_2, \dots, a_n)$.
   - 对每个 $i$ 做 $b_i = a_i / g$.
   - 统计 $\mathrm{cnt1} = |{,i \mid b_i = 1}|$.
   - 如果 $\mathrm{cnt1} > 0$, 则输出 $n - \mathrm{cnt1}$ 并返回。

2. **去重并确定最大值**

   - 对数组 $b$ 排序、去重后保存在 `unique_b` 中.
   - 令 $\text{maxv} = \max(\mathrm{unique_b})$.
   - 构造 DP 数组 `dp[0..maxv]`, 初始值全部设为 $\mathrm{INF}$.

3. **初始化状态 $\mathrm{dp}[b_i] = 0$**

   - 因为如果某个元素恰好等于 $x = b_i$, 就无需操作即可“存在一个值为 $x$”。

4. **从大到小枚举计算 $\mathrm{dp}[x]$**
    对 $x = \text{maxv}\to 1$:

   ```cpp
   for each y in unique_b {
       int u = gcd(x, y);
       dp[u] = min(dp[u], dp[x] + 1);
   }
   ```

   - 理由：若已知让某元素变成 $x$ 需要 $\mathrm{dp}[x]$ 步，那么再对 $x$ 做一次 $\gcd(x, y)$ 操作就可将其变成 $u = \gcd(x, y)$, 共计 $\mathrm{dp}[x] + 1$ 步。因为 $u < x$, 所以需先从大向小遍历。

5. **获取先造出 1 所需的最少步数**

   - 令 `first1 = dp[1]`, 此时 `first1` 是“让某元素先变为 1”的最少操作。
   - 若 `first1 = INF` 则理论不可能（题目保证可行），否则“先造1”需 `first1 - 1` 步。

6. **合成最终答案**

   - “先造1”花费 `first1 - 1` 步；
   - 然后剩下 $n - 1$ 个元素，每个与这个已为 1 的元素各做一次 $\gcd(x,1) = 1$, 共 $n - 1$ 步。
   - 总操作数 = $(first1 - 1) + (n - 1) = first1 + n - 2$.
   - 因为一开始 $\mathrm{cnt1} = 0$, 等价写为 $(first1 - 1) + (n - \mathrm{cnt1})$。



# G. GCD城市探险

link: https://codeforces.com/contest/2037/problem/G

**标签**: 线性筛, 容斥原理, 动态规划, 子集枚举

**题目简述**: 给定 $n$ 个城市及其吸引力 $a_i$，从城市 $i$ 到 $j$ 存在有向边当且仅当 $i<j$ 且 $\gcd(a_i,a_j)>1$，求从 1 到 $n$ 的不同路径数（模 $998244353$）。

**本质思路**  
利用动态规划 $dp[i]$ 表示到达城市 $i$ 的路径数，转移需要快速统计所有 $j<i$ 且 $\gcd(a_j,a_i)>1$ 的 $dp[j]$ 之和：  

- 对每个 $a_i$ 提取互异质因子集合 $P_i$，枚举其所有非空子集 $S\subseteq P_i$，令 $d_S=\prod_{p\in S}p$；  
- 通过容斥原理（奇数子集加，偶数子集减）：  
  $$dp[i]=\sum_{\emptyset\neq S\subseteq P_i}(-1)^{|S|-1}\;\mathrm{cnt}[d_S],$$  
  确保每个符合 $\gcd>1$ 的先前状态恰好计数一次。  
- 枚举完成后，将本次 $dp[i]$ 累加到所有 $\mathrm{cnt}[d_S]$ 中，为后续 $k>i$ 提供统计。

**关键步骤**  

1. **线性筛**：预处理 $\mathrm{spf}[x]$（最小质因子），支持 $O(\log x)$ 分解。  
2. **初始化**：令 $dp[1]=1$，并将其贡献加入各子集的 $\mathrm{cnt}[d_S]$。  
3. **DP 转移**：对 $i=2\dots n$，  
   - 提取 $P_i$，枚举子集计算 $dp[i]$，  
   - 更新 $\mathrm{cnt}[d_S]\mathrel{+}=dp[i]$。  
4. **结果**：输出 $dp[n]$。

整体时间 $O(\max a\log\log\max a + n\times2^{f(a_i)})\le O(n\times128)$。



# F. Ardent Flames

link: https://codeforces.com/contest/2037/problem/F

**标签**: 二分查找, 扫描线, 差分前缀和

**题目简述**: 给定 $n$ 个敌人，位置 $x_i$，生命值 $h_i$，Xilonen 每次选定固定位置 $p$ 进行“地面猛击”，对距离 $d=|p-x_i|<m$ 的敌人造成 $m-d$ 伤害。求最少攻击次数，使得至少 $k$ 个敌人生命降至 0 以下。

**本质思路**  
- **建模检验**：用二分搜索攻击次数 $q$，检查能否在 $q$ 次内击败 $\ge k$ 人  
- **区间化位置**：若要在 $q$ 次内击杀敌人 $i$，每次需伤害 $D_i=\lceil h_i/q\rceil$，应满足 $m-|p-x_i|\ge D_i$，即 $p\in[x_i-(m-D_i),\,x_i+(m-D_i)]$  
- **扫描线判断**：将所有可行区间做差分 $+1$ 在左端，$-1$ 在右端$+1$，按位置前缀和统计覆盖度是否 $\ge k$

**为什么选用此算法**  
- 二分将范围 $[1,\max h_i]$ 划分，外层 $O(\log H)$  
- map离散差分+扫描线合并 $n$ 个区间，$O(n\log n)$  
- 总体 $O(n\log n\log H)$ 可接受

**关键步骤**  
1. **二分攻击次数 $q$**：区间 $l=1,r=\max h_i+1$，中点 $mid$ 检验可行性  
2. **差分数组构造**：对每个敌人若 $D_i\le m$，区间 $[L_i,R_i]$ 执行 `diff[L_i]++`,`diff[R_i+1]--`  
3. **前缀和扫描**：按坐标排序 `diff` 键值，累加前缀和，若任何点覆盖度 $\ge k$ 则可行  
4. **输出结果**：若最终 $r=\max h_i+1$ 则输出 -1，否则输出 $r$


# E. Decode

link: [https://codeforces.com/contest/1996/problem/E](https://codeforces.com/contest/1996/problem/E)

**标签**: 前缀和、哈希计数、贡献压缩

**题目简述**
给定二进制字符串 s（长度 n），统计所有子串 \[x..y]（1≤x≤y≤n）中 0 与 1 数量相等的对子，答案取模 10^9+7。

**本质思路**

* **暴力 O(n²)**：枚举 x,y 检查子串 0/1 个数相等，超时。
* **转化条件**：将 ‘1’ 映射 +1，‘0’ 映射 –1，构建前缀和 pre；
  子串 x..y 0/1 相等 ⇔ pre\[y] == pre\[x–1]。
* **贡献计算**：每对 (j,i) (j\<i, pre\[j]==pre\[i]) 对应所有 (l,r) 包含该子串的数量 = (j+1) \* (n–i+1)。
* **O(n) 聚合**：用哈希表 cnt\[value] 存储所有 j\<i 时 (j+1) 的累加和，
  遍历 i 从 0 到 n，直接做

  ```
  ans += (n–i+1) * cnt[ pre[i] ]
  cnt[ pre[i] ] += (i+1)
  ```

  一次性算出所有 j 的贡献，避免两层循环。

**关键步骤**

1. **前缀和**：pre\[0]=0，pre\[i]=pre\[i–1]+(s\[i]=='1'?+1:–1)。
2. **哈希计数**：维护 map\<int,ll> cnt，cnt\[v] 表示已处理所有 j\<i 且 pre\[j]==v 的 (j+1) 之和。
3. **单次遍历**：
* 每到 i，累加 ans += (n–i+1) \* cnt\[ pre\[i] ]；
   * 再更新 cnt\[ pre\[i] ] += (i+1)。
4. **取模输出**。

整体时间 O(n log n)、空间 O(n)，完美将原本 O(n²) 的两重枚举降至 O(n)。

# F. 炸弹

link: https://codeforces.com/contest/1996/problem/F

**标签**: 二分查找、前$k$大、等差数列求和

**题目简述**  
给定长度为 $n$ 的数组 $a$、$b$ 和操作次数上限 $k$，初始得分为 0。每次选择下标 $i$，得分加上 $a_i$，然后更新 $a_i=\max(0,a_i-b_i)$。求最多能获得的总分。

**本质思路**  
1. 将所有操作值（$a_i, a_i-b_i, a_i-2b_i, \dots$）视作一个多重集合，目标是取出其中前 $k$ 大元素之和。
2. 二分第 $k$ 大元素值 $x$：定义 $f(x)=\sum_i \max(0, \lfloor (a_i-x)/b_i\rfloor+1)$，即操作值大于等于 $x$ 的总次数。找到最大 $x$ 使得 $f(x) \ge k$。
3. 对每个 $i$，若 $a_i \ge x$，令 $t=\lfloor (a_i-x)/b_i\rfloor+1$，则其前 $t$ 次操作值为等差数列 $a_i, a_i-b_i, \dots, a_i-(t-1)b_i$，求和公式为
   $$\sum_{j=0}^{t-1}(a_i - j b_i) = t a_i - \frac{t(t-1)}{2} b_i,$$
   累加到总分 $ans$ 并累加操作次数 $cnt+=t$。
4. 如果 $cnt>k$，则多出的 $cnt-k$ 次操作值均等于 $x$，用
   $$ans -= (cnt-k) \times x$$
   去掉多余贡献。

**关键步骤**  
1. 读入 $a,b,k$。
2. 二分查找 $x$，使用 check(x) 计算 $f(x)$。
3. 累加所有 $\ge x$ 操作的等差和，并统计 $cnt$。
4. 修正 $ans$ 去掉多算部分。

**复杂度**  
- 时间：$O(n \log M)$（$M\approx10^9$）。  
- 空间：$O(n)$。

# G. Omg Graph

link: https://codeforces.com/contest/2117/problem/G

**标签**: 带信息并查集、Kruskal、最小最大组合

**题目简述**  
无向连通带权图，路径代价定义为“路径最小边权 + 路径最大边权”。求 1 → n 所有路径里的最小代价。

**本质思路**  
按权升序遍历边（Kruskal 思路）并维护并查集：根结点记录当前连通块已出现的最小边权。处理每条边 $(u,v,w)$ 时
1. 设两端根为 $r_u,r_v$，并先算块内新的最小值 $m=\min(\text{mn}[r_u],\text{mn}[r_v],w)$；
2. 合并两块，根置为 $r$，写 $\text{mn}[r]=m$；
3. 若此时 $1$ 与 $n$ 已连通，则候选答案为 $\text{mn}[r]+w$；用 ans 取全局最小。
遍历完所有边输出 ans。

**关键步骤**  
- **根信息只在 merge 合并**；`find` 仅路径压缩。
- 遇到“内部边”（两端已同块）也要用 $w$ 更新根最小值。
- 不提前 break，后续更大的 $w$ 仍可能配合更小的 $\text{mn}$ 给出更优解。

**复杂度**  
$O(m\log m)$（排序）+ 近乎 $O(m\alpha(n))$（并查集），空间 $O(n)$。

# D. Graph and Graph

link: [https://codeforces.com/contest/2059/problem/D](https://codeforces.com/contest/2059/problem/D)

**标签**: 状态图最短路、笛卡尔积、Dijkstra、贪心剪枝

**题目简述**
两张同阶连通无向图，各有一枚标记起始于 $s_1,s_2$。
一次操作：在图 1 选邻点 $u_1$，在图 2 选邻点 $u_2$，代价 $|u_1-u_2|$。
无限次操作求 **总代价最小**，若无法使总代价有限输出 −1。

---

**本质思路**

1. **安全点判定**
   若存在公共边 $(v,u)$ 于两图，则状态 $(v,v)$ 可在该边往返，后续代价为 0。
   记满足此条件的顶点 $v$ 为 *good*。问题化为：

   > 起点 $(s_1,s_2)$ **能否**、以及 **以何最小代价** 到达某一 *good* 状态 $(v,v)$。
2. **状态图建模**

   * 顶点：所有有序对 $(x,y)$，共 $n^2$。
   * 边：$(x,y)\to(u,v)$ 当且仅当 $x\sim u$(G₁邻接)，$y\sim v$(G₂邻接)，权 $|u-v|$。
   * 总边数 ≤ $m_1m_2$ (题设 ≤10⁶)，可跑 Dijkstra。
3. **最短路 (lazy)**
   懒扩展：出堆时才穷举 $deg(x)\cdot deg(y)$ 个邻对并松弛；丢弃过期条目。
   复杂度 $O((n^2+m_1m_2)\log n^2)$，数据上限内可通过。

---

**关键步骤**

1. **预处理公共边**

   ```cpp
   set<pair<int,int>> E1;
   // 读 G1 边 -> E1
   // 读 G2 边，如 (v,u)∈E1 ⇒ good[v]=good[u]=true
   ```
2. **Dijkstra over Cartesian product**

   ```cpp
   dist[s1][s2]=0; pq.push({0,{s1,s2}});
   while(!pq.empty()){
        auto [d,{x,y}]=pq.top(); pq.pop();
        if(d!=dist[x][y]) continue;        // 过期
        for(int u: G1[x])
            for(int v: G2[y]){
                long long nd=d+abs(u-v);
                if(nd<dist[u][v]){
                    dist[u][v]=nd;
                    pq.push({nd,{u,v}});
                }
            }
   }
   ```
3. **答案**
   $\min_{v\text{ good}} \text{dist}[v][v]$。若全为 INF ⇒ −1。

---

整体复杂度：

* 时间 $O((n^2+m_1m_2)\log n^2)$。
* 空间 $O(n^2)$。

# G. 二进制字符串众数分解

link: https://codeforces.com/contest/2121/problem/G

**标签**: 二进制、前缀和、排序、数学

**题目简述**: 给定长度为 n 的二进制字符串 s，求所有子串 s\[l..r] 中 f(s\[l..r]) 的总和，其中 f(p) 为 p 中 0 和 1 出现次数的最大值。

**本质思路**
利用 $f=\frac{L+|z-o|}2$，把总和拆成两部分：子串长度之和和绝对差之和。前者用公式 $\sum_{i=0}^{n-1}(i+1)(n-i)$ 线性求；后者排序前缀差并累加邻差乘出现次数高效算出。

**关键步骤**

1. 计算前缀差 `pre[i]=#0(1…i)-#1(1…i)`，长度 n+1
2. 对 `pre` 排序得 b\[0…n]，累加 $\sum_{k=1}^n(b_k-b_{k-1})\times k\times(n+1-k)$
3. 计算所有子串长度之和：$\sum_{i=0}^{n-1}(i+1)(n-i)$
4. 答案 = (差分绝对值和 + 长度和) / 2

**复杂度**: 时间 O(n log n)，空间 O(n)

```cpp
    int n;
    string s;
    cin >> n >> s;
    vector<int> pre(n + 1);
    for (int i = 0; i < n; ++i) {
        // 前缀差：0 记 -1，1 记 +1
        pre[i + 1] = pre[i] + (s[i] == '0' ? -1 : 1);
    }
    std::ranges::sort(pre);
    ll ans = 0;
    // 累加前缀差绝对值和部分
    for (ll i = 1; i <= n; ++i) {
        ans += (pre[i] - pre[i - 1]) * i * (n - i + 1);
    }
    // 累加所有子串长度和部分
    for (ll i = 0; i < n; ++i) {
        ans += (i + 1) * (n - i);
    }
    // 合并除以 2
    ans >>= 1;
    cout << ans << "\n";
```

# F. Yamakasi

link: [https://codeforces.com/contest/???/problem/F](https://codeforces.com/contest/???/problem/F)

**标签**: 前缀和、哈希、区间断开、容斥

**题目简述**
给定数组 $a_1\dots a_n$ 及整数 $s,x$。统计满足两条件的子段数：① 元素和为 $s$；② 子段最大值为 $x$。

**本质思路**
利用容斥拆为两计数函数：
$$
\text{ans}=\underbrace{\#\bigl[\text{sum}=s,\;\max\le x\bigr]}_{f(x)}-\underbrace{\#\bigl[\text{sum}=s,\;\max\le x-1\bigr]}_{f(x-1)}.
$$

每个 $f(p)$ 通过「遇到 $a_i>p$ 清空统计器」的技巧在线计算。

**关键步骤**

1. **前缀和**  $pre[i]=\sum_{1..i}a_i$。
2. **分段统计**  遍历 $i$，若 $a_i>p$ 清空 `cnt`（断开）。否则：

   * 若 `cnt` 中存在键 $pre[i]-s$，将其频次加至答案。
   * 将当前前缀 $pre[i]$ 写回 `cnt`。
3. **两遍调用**  分别算 $f(x)$、$f(x-1)$，相减即得结果。

**复杂度**
时间 $O(n\log n)$（`map`）或 $O(n)$（`unordered_map`）；空间 $O(n)$。


# L. 三点最小点积

link: https://codeforces.com/gym/105941

**标签**: 凸包、旋转卡壳 (双指针)、点积优化

**题目简述**  
给定 $n$ 个点，从中选三点 $A,B,C$ 使  
$$(B-A)\cdot(C-A)$$  
最小。输出最小值。

---

## 本质思路  
1. 对固定 $A$，函数 $f_{A}(B,C)=(B-A)\cdot(C-A)$ **关于 $B,C$ 是线性**；  
   线性目标在凸集上极值必取于凸包极点 ⇒ 最优 $B,C$ 必在输入点的凸包顶点上。  
2. 枚举 $A\in$ 所有输入点，枚举 $B\in$ 凸包顶点。  
3. 对每对 $(A,B)$，$f_A$ 关于 $C$ 沿凸包呈单峰（投影一维单调）→ 用双指针维护最优 $C$。  
   `cp` 只前移不回退，整体 $O(h)$。  

---

## 关键步骤

1. **凸包**  
   Andrew 单调链，得到逆时针顶点序 `hull`，$h\le n$。  
2. **枚举**  
   
   ```pseudo
   ans = 0
   for A in points:
       cp = 1
       for bp = 0..h-1:          // B = hull[bp]
           if B==A: continue
           AB = B - A
           if bp==0: cp = 1
           if cp==bp: cp = (cp+1)%h
           // 旋转卡壳：单调前移 cp
           while dot(AB, hull[nxt]-A) < dot(AB, hull[cp]-A):
               cp = nxt
           ans = min(ans, dot(AB, hull[cp]-A))
   ```
   
3. **输出** `ans`。

---

## 整体复杂度

* 凸包 `O(n log n)`
* 主循环 `O(n h)`，最坏 `O(n²)` (≤ ≈4e7)
* 空间 `O(n)`

# D. XOR 最短路径

link: https://atcoder.jp/contests/abc410/tasks/abc410_d

**标签**: BFS、图论、状态拓展、按位异或

**题目简述**:
给定一个有向带权图，包含 $N$ 个顶点和 $M$ 条边，每条边从 $A_i$ 到 $B_i$ 权值为 $W_i$。求从顶点 $1$ 到顶点 $N$ 的一条路径，使得路径上所有边权的按位 XOR 值最小；若不存在路径则输出 $-1$。

**本质思路**
通过“状态拓展”将原图中每个顶点 $x$ 拓展为多种状态 $(x, s)$，其中 $s$ 表示从 1 到 $x$ 的路径 XOR 值。在这个隐式状态图上做 BFS，层序遍历保证第一次访问到 $(N, s)$ 的 $s$ 即为最小 XOR。

**关键步骤**

1. **状态定义**
   - 用二维数组 `vis[x][s]` 表示状态 $(x,s)$ 是否已访问。
2. **初始化**
   - `vis[1][0] = true`，将状态 $(1,0)$ 入队。
3. **BFS 过程**
   - 当队列非空时，取出 $(x, s)$，遍历原图中所有出边 $(x\to y, w)$：
     - 计算新状态 `s2 = s XOR w`
     - 若 `vis[y][s2] == false`，则标记 `vis[y][s2] = true` 并入队 $(y, s2)$。
4. **答案提取**
   - BFS 结束后，从 $s=0$ 到 $1023$ 依次检查 `vis[N][s]`：
     - 首个为 `true` 的 $s$ 即为答案；若无，则输出 `-1`。

整体复杂度：
- 时间复杂度： $O((N+M)\times 2^{10})$
- 空间复杂度： $O(N\times 2^{10})$


# E1. The Game (Easy Version)

link: https://codeforces.com/contest/2062/problem/E1

**标签**: 树, 欧拉序 (Euler Tour), 前缀后缀最值, 博弈

**题目简述**: 给定带权有根树，琪露诺先手，首选删除某节点子树，之后双方只能删除权值比上次删除节点权值更大的子树。无法操作者获胜，求一个能让 琪露诺获胜的起始节点。

**本质思路**  
利用 Euler Tour 将树扁平化为序列，使子树对应连续区间。这样「子树外是否存在更大权值」可转化为前缀/后缀最大值比较问题。  
琪露诺要获胜，首选节点 u 必须满足子树外存在权值 > w[u] 的节点，且选取的 u 权值最大，以确保对手无可行操作。

**关键步骤**  
1. **DFS 扁平化**：记录进入时间 tin[u] 和离开时间 tout[u]，并在数组 `order` 中记录序号 → 节点映射。  
2. **前缀后缀最值**：构造 `pre[i] = max(pre[i-1], w[order[i]])` 和 `suf[i] = max(suf[i+1], w[order[i]])`。  
3. **合法性判断**：对于每个 u，子树区间为 `[tin[u], tout[u]]`，子树外最值为 `max(pre[tin[u]-1], suf[tout[u]+1])`；若该值 > w[u]，则 u 合法。  
4. **取最优**：在所有合法 u 中，选取 w[u] 最大者作为答案；若无合法，输出 0。  

**复杂度**：  

- 时间：O(n)（一次 DFS + 两次线性扫描 + 遍历判断）  
- 空间：O(n)


# F. 平衡矩形

link: https://atcoder.jp/contests/abc410/tasks/abc410_f

**标签**: 枚举, 差分数组, 前缀和, 计数优化

**题目简述**:  给定一个 $H	imes W$ 的网格，统计其中所有子矩阵里 `#` 与 `.` 数量相等的矩形个数。

**本质思路**  
固定上下边 $(u,d)$，将这些行区间内第 $k$ 列的 `#`–`.` 差值累加到一维数组 $C$。子矩阵平衡等价于 $C[l]+C[l+1]+\dots+C[r]=0$，即寻找一维零和子段。枚举行边 $O(H^2)$，每次一维统计 $O(W)$，整体 $O(H^2W)$。

**关键步骤**  
1. 若 $H>W$，首先转置矩阵保证 $H\le W$。
2. 令 `ofs = H*W`，开长度 $2\cdot ofs+1$ 的频次数组 `cnt`。
3. 枚举上边 `i` 从 $0$ 到 $H-1$, 下边 `j` 从 `i` 到 $H-1$：  
   - 维护一维差分 `d[k] += (grid[j][k]=='#'?1:-1)`。  
   - 令 `cnt[ofs]=1`, `prefix=0`。  
   - 遍历列 `k=0..W-1`：  
     1. `prefix += d[k]`  
     2. `ans += cnt[prefix + ofs]`  
     3. `cnt[prefix + ofs]++`  
   - 回退：将 `cnt[ofs]` 和所有访问过的 `cnt[p+=ofs]` 重置为 0。  
4. 最终输出 `ans`。

**复杂度**  

- 时间：$O(H^2W)$  
- 空间：$O(HW)$

# C. 骗子说谎方案数

link: [https://codeforces.com/contest/2061/problem/C](https://codeforces.com/contest/2061/problem/C)

**标签**: DP, 计数, 状态压缩, 不相邻限制

**题目简述**: 排列 n 名同学，每人要么诚实报告左侧骗子数 a\_i，要么说谎（不能和相邻说谎者并立），骗子报告左侧真实的骗子数等于 a\_{i-1}+1。求满足所有陈述的排列数 mod 998244353。

**本质思路**

1. **建模**：用等式约束诚实/说谎两种情况，并利用“不相邻骗子”将说谎者情形强制转化为“前一位诚实”。
2. **状态压缩**：定义 dp\[i] = 前 i 人且第 i 人诚实的方案数，转移仅依赖 dp\[i-1]（i-1 诚实）和 dp\[i-2]（i-1 骗子）两种来源。
3. **高效计数**：一次线性遍历，O(n) 累加合法转移，最后 ans = dp\[n] + dp\[n-1]。

**关键步骤**

1. **初始化**
   设虚拟 a\[0]=0，dp\[0]=1。

2. **状态转移**

   * 若 a\[i] == a\[i-1]，则第 i 来源于 i-1 诚实：dp\[i] += dp\[i-1]。
   * 若 i>=2 且 a\[i] == a\[i-2] + 1，则第 i 来源于 i-1 骗子（i-2 诚实）：dp\[i] += dp\[i-2]。

3. **结果汇总**
   最后一人可诚实（dp\[n]）或作骗子（dp\[n-1]），ans = (dp\[n] + dp\[n-1]) mod 998244353。

**复杂度**: 时间 O(n)，空间 O(n)（可滚动优化至 O(1)）。

# F. Joker

link: [https://codeforces.com/contest/2051/problem/F](https://codeforces.com/contest/2051/problem/F)

**标签**: 模拟, 区间合并

**题目简述**:
有一副包含 $n$ 张牌的牌堆，编号由上至下为 $1$ 到 $n$。小丑牌初始位于位置 $m$。依次进行 $q$ 次操作，每次给定位置 $a_i$，将第 $a_i$ 张牌移动到牌堆开头或末尾。求每次操作后，小丑牌可能的不同位置数量。

**本质思路**
用最多三段区间维护所有可能位置：

* **头段**（可能移到开头后扩展）
* **中段**（未移出的原区间）
* **尾段**（可能移到末尾后扩展）
  每次操作基于 $a_i$ 与区间关系常数更新，合并三段计算总长度。

**关键步骤**

1. **初始化三段**

   * 头段：$[1,-q]$（l>r 表示未激活）
   * 中段：$[m,m]$
   * 尾段：$[n+q+1,n]$（l>r 表示未激活）
2. **处理操作 $a_i$**

   * 遍历三段 $[l,r]$：

     * 若 $a_i<l$：$l=\max(1,l-1)$
     * 若 $a_i>r$：$r=\min(n,r+1)$
     * 否则：标记 `ins=true`，若 $l=r$ 则销毁该段（置为无效）
3. **激活新段**（若 `ins=true`）

   * 头段置为 $[1,1]$
   * 尾段置为 $[n,n]$
4. **合并三段**并累加不重叠长度，得答案

**复杂度**
时间 $O(q)$，空间 $O(1)$。

## G. 树的破坏
**link**: https://codeforces.com/problemset/problem/2050/G  
**标签**: 树 DP、贪心  

**题目简述**  
删除树上一条路径后，根据被切断的边数求最大连通分量数。

**本质思路**  
1. **权值建模**：设每个顶点权重 \(w(v)=\deg(v)-2\)，路径权和再加 3 即为分量数。  
2. **双态 DP**：  
   - \(dp_x(v)\)：以 \(v\) 为顶点、向下一支路径的最大权和；  
   - \(dp_y(v)\)：经 \(v\) 从一子树到另一子树的最大权和。  
3. **后序遍历合并子结果**：维护两大子贡献 \(m_1,m_2\)，依次更新 \(dp_x,dp_y\)。  
4. **答案取全局最大**：\(\max_v\{\max(dp_x(v),dp_y(v))\}+3\)。

**关键伪代码**  
```
dfs(v):
  dp_x(v)=deg(v)
  collect dp_x(u)  // 所有子 u 的结果
  m1,m2=两大值
  dp_x(v)=max(dp_x(v), m1+deg(v)-2)
  if m2 存在: dp_y(v)=m1+m2+deg(v)-4 else dp_y(v)=dp_x(v)
```

**复杂度**  
- 时间 \(O(n)\)，空间 \(O(n)\)。
# K. 环面路径

link: https://codeforces.com/contest/1765/problem/K

**标签**: 贪心、矩阵、遍历、数学证明

**题目简述**:  
在 \(n * n\) 的环面网格上，从 \((1,1)\) 移动到 \((n,n)\)，只能向右或向下移动且不能重访，求路径所能获得的最大格子和。

**本质思路**  

1. **本质考点**：识别反对角线上的“瓶颈”割集——在环面拓扑下，反对角线 \(\{(i,n+1-i)\}\) 上最多能访问 \(n-1\) 个点  
2. **为什么选用此算法**：直接数学证明入度瓶颈 + 简单线性扫描，无需动态规划，复杂度降到 \(O(n^2)\)  
3. **模块化复盘**：  
   - 模块1：遍历求全矩阵元素和  
   - 模块2：扫描反对角线取最小值  
   - 模块3：结果 = 总和 − 最小值

**关键步骤**  

1. 读入并累加所有 \(a_{i,j}\) 为 `sum`  
2. 对所有 \((i,n-1-i)\) 取 `mn = min(mn, a[i][n-1-i])`  
3. 输出 `sum - mn`

**整体复杂度**：\(O(n^2)\)  
**空间复杂度**：\(O(n^2)\)  

# D. Unique Median

link: [https://codeforces.com/problemset/problem/2056/D](https://codeforces.com/problemset/problem/2056/D)

**标签**: 枚举、前缀和、哈希、双指针

**题目简述**
统计数组 $a$ 所有子数组中“中位数唯一”的个数。已知 $1\le a_i\le10$。

**本质思路**
偶长子数组若“大于 x”与“≤ x”元素数目相等且区间内出现 $x$，则两个中位数同为 $x$，中位数不唯一。
→ 枚举 $x=1\ldots10$，把

$$
b_i=\begin{cases}
+1,&a_i>x\\
-1,&a_i\le x
\end{cases}
$$

对子数组和为 0 且包含 $x$ 的区间计数为 **bad**；答案 = 全部子数组数 − bad。

**关键步骤**

1. **全部子数组数** $all = n(n+1)/2$。
2. **枚举$x$**

   1. 计算前缀和 `pre[k]=Σ_{0..k-1} b`。
   2. 用 `map<int,int> cnt` 记录已激活前缀和出现次数；指针 `j` 表示激活到的位置。
   3. 扫描右端 `i`：

      * 若 `a[i]==x`，将 `pre[j..i]` 加入 `cnt`（保证区间含 $x$）。
      * 累加 `bad += cnt[pre[i+1]]`（和为 0 的区间数）。
3. **输出** `all - bad`。

**整体复杂度** 时间 $O(10n)$，空间 $O(n)$。

---

```cpp
    using ll = long long;
    int n;  cin >> n;
    vector<int> a(n); for (int &v: a) cin >> v;
    ll all = 1LL * n * (n + 1) / 2, bad = 0;

    for (int x = 1; x <= 10; ++x) {
        vector<int> pre(n + 1);
        for (int i = 0; i < n; ++i)          // 前缀和
            pre[i + 1] = pre[i] + (a[i] > x ? 1 : -1);

        map<int,int> cnt;
        int j = 0;
        for (int i = 0; i < n; ++i) {
            if (a[i] == x)                   // 激活左端
                while (j <= i) ++cnt[pre[j++]];
            bad += cnt[pre[i + 1]];          // 统计坏区间
        }
    }
    cout << all - bad << '\n';
```

**复杂度** $O(10n)$ | $O(n)$

# C. Manhattan Pairs

**link**: [https://codeforces.com/contest/2122/problem/C](https://codeforces.com/contest/2122/problem/C)

**标签**: 排序 · 集合划分 · 贪心 · 曼哈顿距离

---

## 题目简述

给定偶数个平面点 $(x_i,y_i)$，选出 $n/2$ 对，使所有配对的曼哈顿距离和最大。

---

## 本质思路

1. **曼哈顿距离可分离性**：
   $|x_a-x_b|+|y_a-y_b|$ 可拆为 **x** 和 **y** 两维最优配对之和。
2. **1D 最优配对**：
   将一维数值排序后，将最小的与最大的配对，能获得最大距离和。
3. **分区与交叉配对**：

   * 全局按 **x** 排序二分，得到前半区 $X_0$（最小）与后半区 $X_1$（最大）。
   * 在各半区内部按 **y** 排序，得到子集 A=$X_0∩Y_0$、B=$X_0∩Y_1$、C=$X_1∩Y_0$、D=$X_1∩Y_1$。
   * 交叉配对 A↔D、B↔C，同时跨越 x、y 维度的最小/最大半区。

---

## 最优性保证

1. **x 维最优**：
   任何跨越 $X_0$ 与 $X_1$ 的配对，x 维距离和固定为
   $  \sum_{j\in X_1}x_j - \sum_{i\in X_0}x_i$
   ，与具体配对方式无关，且为最大。
2. **y 维最优**：
   同理，跨越 $Y_0$ 与 $Y_1$ 的配对，y 维距离和最大且不依赖配对细节。
3. **全局最优**：
   A↔D 与 B↔C 恰好同时实现两维跨半区，距离和等于 x、y 两维最优之和。

---

## 关键步骤

1. **按 x 排序**：前 $n/2$ 为 $X_0$，后 $n/2$ 为 $X_1$。
2. **对 $X_0$ 内按 y 排序**：分出 A（$Y_0$）与 B（$Y_1$）。
3. **对 $X_1$ 内按 y 排序**：分出 C 与 D。
4. **合并 \[A,B,C,D]**：双指针首尾配对，输出对应点索引。

---

## 复杂度

* 时间：$O(n\log n)$
* 空间：$O(n)$
