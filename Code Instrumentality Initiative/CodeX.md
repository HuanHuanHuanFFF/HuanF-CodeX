# D. 音乐预测

link: https://codeforces.com/contest/2042/problem/D

**标签**：扫描线、区间覆盖、离线处理、平衡树、有序集合、对称化

**本质思路**  
通过离线处理（按左端排序）和有序集合（`std::set.lower_bound`）将时间复杂度从 \(O(n^2)\) 降到 \(O(n\log n)\)。

**关键步骤**

1. **离线排序**  
   将所有区间按 \((l\ ↑,\ r\ ↓)\) 排序，保证遍历到 \([l_i,r_i]\) 时，所有满足 \(l_j\le l_i\) 的候选 predictors 已加入数据结构。
2. **在线查询**  
   用 `set<int>` 存放已处理区间的右端点，在遍历时用 `lower_bound(r_i)` 找到最小的 \(r_j\ge r_i\)，即 predictors 交集的右端，累加
   \(\max(0,\,r_j - r_i)\)。
3. **对称化处理**  
   将区间映射为 \([-r,-l]\) 后复用同样流程，得到左端推荐长度 \(\max(0,\,l_i - L)\)。
4. **去重**  
   相同原始区间的用户答案置 0。

整体复杂度：两次 \(O(n\log n)\) 扫描，合计 \(O(n\log n)\)。

# K. 渡劫

link: https://codeforces.com/gym/105423

**标签**：状态扩展、分层图、Dijkstra、最短路、超级源

**本质思路**  
将“一次免费通道”作为状态扩展成两层节点（未用/已用），再连同“直接完成渡劫”的超级源边，转化为单源最短路问题，最后取“已用免费”层最短路的最大值。

**关键步骤**

1. **状态扩展**  
   将每个岛屿 \(i\) 拆为两层节点：\(i^{(0)}\)（未用免费）与 \(i^{(1)}\)（已用免费）。

2. **同层建边**  
   对每条隧道 \((u,v)\) 权重 \(w\)，在层0和层1分别添加双向边 \((u\leftrightarrow v)\) 权重 \(w\)。

3. **跨层免费边**  
   在层0的 \((u^{(0)}\to v^{(1)})\) 和 \((v^{(0)}\to u^{(1)})\) 各添加一条权重 \(0\) 的边，模拟一次免费穿越。

4. **自跨层跳转**  
   在每个节点添加 \((i^{(0)}\to i^{(1)})\) 权重 \(0\) 的边，以支持“在岛上直接用免费机会”情形。

5. **超级源建模**  
   添加源点 \(S\)，对每个 \(i^{(0)}\) 添加边 \((S\to i^{(0)})\) 权重 \(a_i\)，表示不走隧道直接在岛上完成渡劫的消耗。

6. **跑 Dijkstra**  
   在包含 \(2n+1\) 个节点的分层图上，从 \(S\) 出发求最短路。

7. **结果聚合**  
   答案为所有“已用免费层”节点 \(\max_{1\le i\le n} \mathrm{dist}(i^{(1)})\)。

整体复杂度：\(O((n+m)\log(n+m))\)  
