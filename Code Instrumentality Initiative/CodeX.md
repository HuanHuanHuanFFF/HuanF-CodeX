# D. 音乐预测

link: https://codeforces.com/contest/2042/problem/D

**标签**：扫描线、区间覆盖、离线处理、平衡树、有序集合、对称化

**本质思路**  
通过离线处理（按左端排序）和有序集合（`std::set.lower_bound`）将时间复杂度从 \(O(n^2)\) 降到 \(O(n\log n)\)。

**关键步骤**

1. **离线排序**  
   将所有区间按 \((l\ ↑,\ r\ ↓)\) 排序，保证遍历到 \([l_i,r_i]\) 时，所有满足 \(l_j\le l_i\) 的候选 predictors 已加入数据结构。
2. **在线查询**  
   用 `set<int>` 存放已处理区间的右端点，在遍历时用 `lower_bound(r_i)` 找到最小的 \(r_j\ge r_i\)，即 predictors 交集的右端，累加
   \(\max(0,\,r_j - r_i)\)。
3. **对称化处理**  
   将区间映射为 \([-r,-l]\) 后复用同样流程，得到左端推荐长度 \(\max(0,\,l_i - L)\)。
4. **去重**  
   相同原始区间的用户答案置 0。

整体复杂度：两次 \(O(n\log n)\) 扫描，合计 \(O(n\log n)\)。

# K. 渡劫

link: https://codeforces.com/gym/105423

**标签**：状态扩展、分层图、Dijkstra、最短路、超级源

**本质思路**  
将“一次免费通道”作为状态扩展成两层节点（未用/已用），再连同“直接完成渡劫”的超级源边，转化为单源最短路问题，最后取“已用免费”层最短路的最大值。

**关键步骤**

1. **状态扩展**  
   将每个岛屿 \(i\) 拆为两层节点：\(i^{(0)}\)（未用免费）与 \(i^{(1)}\)（已用免费）。

2. **同层建边**  
   对每条隧道 \((u,v)\) 权重 \(w\)，在层0和层1分别添加双向边 \((u\leftrightarrow v)\) 权重 \(w\)。

3. **跨层免费边**  
   在层0的 \((u^{(0)}\to v^{(1)})\) 和 \((v^{(0)}\to u^{(1)})\) 各添加一条权重 \(0\) 的边，模拟一次免费穿越。

4. **自跨层跳转**  
   在每个节点添加 \((i^{(0)}\to i^{(1)})\) 权重 \(0\) 的边，以支持“在岛上直接用免费机会”情形。

5. **超级源建模**  
   添加源点 \(S\)，对每个 \(i^{(0)}\) 添加边 \((S\to i^{(0)})\) 权重 \(a_i\)，表示不走隧道直接在岛上完成渡劫的消耗。

6. **跑 Dijkstra**  
   在包含 \(2n+1\) 个节点的分层图上，从 \(S\) 出发求最短路。

7. **结果聚合**  
   答案为所有“已用免费层”节点 \(\max_{1\le i\le n} \mathrm{dist}(i^{(1)})\)。

整体复杂度：\(O((n+m)\log(n+m))\)

# D. 禁止前缀

link: https://atcoder.jp/contests/abc403/tasks/abc403_d

**标签**：计数、分组 DP、二状态 DP

**本质思路**  
将所有元素按索引对 _d_ 取模分为 _d_ 组，在每组内做二状态线性 DP：对每个值选择“删除/保留”，用 `dp0`/`dp1`
分别维护上一个位置删除或保留的最小删除数，从而计算该组最少需要删除多少元素，最终累加得答案。

**关键步骤**

1. **统计频次**  
   用 `cnt[x]` 记录每个值 x 在序列中出现的次数。
2. **处理 d=0**  
   若 _d_ == 0，则每个值只能保留一个，删除次数为 ∑(cnt[x]−1)。
3. **分组遍历**  
   对 `r` 从 0 到 _d−1_：
    - 初始化 `dp0=0, dp1=0`
    - 按 `i = r; i < A; i += d` 遍历该组所有值（A 为数值上限）：
        - 令 `c = cnt[i]`
        - `ndp0 = min(dp0, dp1) + c` （删除当前，需删 c 个）
        - `ndp1 = dp0` （保留当前，则上一个必须删）
        - 更新 `dp0=ndp0, dp1=ndp1`
    - 该组最少删除 `min(dp0, dp1)`，累加到总答案
4. **输出答案**  
   累加所有组的最少删除次数即为最终最少删除数

整体复杂度：O(n + A)，空间复杂度 O(A)

# D. ABC400-D 高桥买鱼

link: https://atcoder.jp/contests/abc400/tasks/abc400_d

**标签**：图论、0-1 BFS、最短路、网格图

**本质思路**  
将每个格子视作图的节点，邻接无墙一步移动为权值 0 边，遇墙或跨越障碍为权值 1 边，使用 0-1 BFS 在双端队列中维护最少踢墙次数

**关键步骤**

1. **建模图结构**
    - 节点：(i,j) 对应网格格点
    - 边：对四个方向尝试一步或两步移动
        - 若移动过程中未遇墙且步长=1，权值 0
        - 否则视为“踢墙”，权值 1
2. **0-1 BFS**
    - 初始化 `hit[sx][sy] = 0`，将起点 `(sx,sy)` 加入 `deque`
    - 每次从队首弹出 `(x,y)`，若为终点 `(tx,ty)`，输出 `hit[x][y]` 并结束
    - 否则对四个方向和两种步长：
        - 计算 `(nx,ny)`，若越界则 `break`
        - 若路径至此未遇墙且步长=1：
            - `hit[nx][ny] = hit[x][y]`
            - `push_front((nx,ny))`
        - 否则：
            - `hit[nx][ny] = hit[x][y] + 1`
            - `push_back((nx,ny))`
3. **输出答案**
    - 当终点首次弹出时即为最优答案
4. **复杂度**
    - 时间 O(h·w)，空间 O(h·w)

# C. 钓鱼竞赛 (Competitive Fishing)

**link**：https://codeforces.com/contest/2042/problem/C  
**标签**：贪心、后缀差分、排序

**本质思路**  
从后向前遍历字符串，维护后缀中 Bob 鱼（‘1’）与 Alice 鱼（‘0’）数量差 `sum`。只有当 `sum>0` 时，在这一位置划分一组才能为 Bob
带来正向增益，将所有这样的 `sum` 收集到 `vals` 中，排序后贪心取最大的增益，直到累计增益 ≥ k。

**关键步骤**

1. **后缀累积差分**
    - 初始化 `sum=0`，遍历 `i=n-1…1`：
      ```cpp
      sum += (s[i]=='1' ? 1 : -1);
      if (sum>0) vals.push_back(sum);
      ```
2. **贪心选组**
    - 将 `vals` 排序升序，设 `ans=1`（至少一组）。
    - 反复取出 `vals.back()`：
      ```cpp
      while (k>0 && !vals.empty()) {
        k -= vals.back();
        vals.pop_back();
        ++ans;
      }
      ```
3. **输出结果**
    - 若最终 `k>0` 则输

# P1173. 旅行计划

link: https://www.luogu.com.cn/problem/P1137

**标签**：DAG DP、拓扑排序、最长路径

**本质思路**  
将“只能从西向东”限制视作一个有向无环图（DAG），在 DAG 上对每个节点求最长可达路径长度。

**关键步骤**

1. **建图与初始化**
    - 用邻接表 `g[x]` 存储有向边 `x→y`，并用 `in[y]++` 记录每个节点的入度；
    - 数组 `dp[i]=1`，表示以节点 i 结尾的最长路径至少包含自己。

2. **拓扑排序 (Kahn 算法)**
    - 将所有 `in[i]==0` 的节点入队；
    - 依次弹出队首 `u`，并处理其每条出边 `u→v`。

3. **DP 松弛**
   ```cpp
   dp[v] = max(dp[v], dp[u] + 1);
   if (--in[v] == 0) q.push(v);

# F. Clique in the Divisibility Graph

link: https://codeforces.com/problemset/problem/566/F

**标签**：DAG DP、筛法、数论、最长链

**本质思路**  
最大团即全互整除的元素集合，在整除关系偏序（DAG）上求最长链,变成了DAG on DP

示意图:

       3
     / | \
    v  v  v
    6  9  12
     \  |    \
      vv     v
      18     24
       \     /  \
        v   v    v
         72      48

**关键步骤**

1. **标记出现**
    - `has[i] = true` 表示元素 `i` 在输入集合中出现；
2. **初始化 DP**
    - `dp[i] = 1`，表示单个元素自成长度为 1 的链；
3. **升序枚举 & 埃氏筛**

  ```cpp
   for (int x : a) {
       // 枚举 x 的所有倍数 y
       for (int y = x * 2; y < N; y += x) {
           if (has[y])
               dp[y] = max(dp[y], dp[x] + 1);
       }
   }