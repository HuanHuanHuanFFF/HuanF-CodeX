# D. 音乐预测

link: https://codeforces.com/contest/2042/problem/D

**标签**：扫描线、区间覆盖、离线处理、平衡树、有序集合、对称化

**本质思路**  
通过离线处理（按左端排序）和有序集合（`std::set.lower_bound`）将时间复杂度从 \(O(n^2)\) 降到 \(O(n\log n)\)。

**关键步骤**

1. **离线排序**  
   将所有区间按 \((l\ ↑,\ r\ ↓)\) 排序，保证遍历到 \([l_i,r_i]\) 时，所有满足 \(l_j\le l_i\) 的候选 predictors 已加入数据结构。
2. **在线查询**  
   用 `set<int>` 存放已处理区间的右端点，在遍历时用 `lower_bound(r_i)` 找到最小的 \(r_j\ge r_i\)，即 predictors 交集的右端，累加
   \(\max(0,\,r_j - r_i)\)。
3. **对称化处理**  
   将区间映射为 \([-r,-l]\) 后复用同样流程，得到左端推荐长度 \(\max(0,\,l_i - L)\)。
4. **去重**  
   相同原始区间的用户答案置 0。

整体复杂度：两次 \(O(n\log n)\) 扫描，合计 \(O(n\log n)\)。

# K. 渡劫

link: https://codeforces.com/gym/105423

**标签**：状态扩展、分层图、Dijkstra、最短路、超级源

**本质思路**  
将“一次免费通道”作为状态扩展成两层节点（未用/已用），再连同“直接完成渡劫”的超级源边，转化为单源最短路问题，最后取“已用免费”层最短路的最大值。

**关键步骤**

1. **状态扩展**  
   将每个岛屿 \(i\) 拆为两层节点：\(i^{(0)}\)（未用免费）与 \(i^{(1)}\)（已用免费）。

2. **同层建边**  
   对每条隧道 \((u,v)\) 权重 \(w\)，在层0和层1分别添加双向边 \((u\leftrightarrow v)\) 权重 \(w\)。

3. **跨层免费边**  
   在层0的 \((u^{(0)}\to v^{(1)})\) 和 \((v^{(0)}\to u^{(1)})\) 各添加一条权重 \(0\) 的边，模拟一次免费穿越。

4. **自跨层跳转**  
   在每个节点添加 \((i^{(0)}\to i^{(1)})\) 权重 \(0\) 的边，以支持“在岛上直接用免费机会”情形。

5. **超级源建模**  
   添加源点 \(S\)，对每个 \(i^{(0)}\) 添加边 \((S\to i^{(0)})\) 权重 \(a_i\)，表示不走隧道直接在岛上完成渡劫的消耗。

6. **跑 Dijkstra**  
   在包含 \(2n+1\) 个节点的分层图上，从 \(S\) 出发求最短路。

7. **结果聚合**  
   答案为所有“已用免费层”节点 \(\max_{1\le i\le n} \mathrm{dist}(i^{(1)})\)。

整体复杂度：\(O((n+m)\log(n+m))\)

# D. 禁止前缀

link: https://atcoder.jp/contests/abc403/tasks/abc403_d

**标签**：计数、分组 DP、二状态 DP

**本质思路**  
将所有元素按索引对 _d_ 取模分为 _d_ 组，在每组内做二状态线性 DP：对每个值选择“删除/保留”，用 `dp0`/`dp1`
分别维护上一个位置删除或保留的最小删除数，从而计算该组最少需要删除多少元素，最终累加得答案。

**关键步骤**

1. **统计频次**  
   用 `cnt[x]` 记录每个值 x 在序列中出现的次数。
2. **处理 d=0**  
   若 _d_ == 0，则每个值只能保留一个，删除次数为 ∑(cnt[x]−1)。
3. **分组遍历**  
   对 `r` 从 0 到 _d−1_：
    - 初始化 `dp0=0, dp1=0`
    - 按 `i = r; i < A; i += d` 遍历该组所有值（A 为数值上限）：
        - 令 `c = cnt[i]`
        - `ndp0 = min(dp0, dp1) + c` （删除当前，需删 c 个）
        - `ndp1 = dp0` （保留当前，则上一个必须删）
        - 更新 `dp0=ndp0, dp1=ndp1`
    - 该组最少删除 `min(dp0, dp1)`，累加到总答案
4. **输出答案**  
   累加所有组的最少删除次数即为最终最少删除数

整体复杂度：O(n + A)，空间复杂度 O(A)

# D. ABC400-D 高桥买鱼

link: https://atcoder.jp/contests/abc400/tasks/abc400_d

**标签**：图论、0-1 BFS、最短路、网格图

**本质思路**  
将每个格子视作图的节点，邻接无墙一步移动为权值 0 边，遇墙或跨越障碍为权值 1 边，使用 0-1 BFS 在双端队列中维护最少踢墙次数

**关键步骤**

1. **建模图结构**
    - 节点：(i,j) 对应网格格点
    - 边：对四个方向尝试一步或两步移动
        - 若移动过程中未遇墙且步长=1，权值 0
        - 否则视为“踢墙”，权值 1
2. **0-1 BFS**
    - 初始化 `hit[sx][sy] = 0`，将起点 `(sx,sy)` 加入 `deque`
    - 每次从队首弹出 `(x,y)`，若为终点 `(tx,ty)`，输出 `hit[x][y]` 并结束
    - 否则对四个方向和两种步长：
        - 计算 `(nx,ny)`，若越界则 `break`
        - 若路径至此未遇墙且步长=1：
            - `hit[nx][ny] = hit[x][y]`
            - `push_front((nx,ny))`
        - 否则：
            - `hit[nx][ny] = hit[x][y] + 1`
            - `push_back((nx,ny))`
3. **输出答案**
    - 当终点首次弹出时即为最优答案
4. **复杂度**
    - 时间 O(h·w)，空间 O(h·w)

# C. 钓鱼竞赛 (Competitive Fishing)

**link**：https://codeforces.com/contest/2042/problem/C  
**标签**：贪心、后缀差分、排序

**本质思路**  
从后向前遍历字符串，维护后缀中 Bob 鱼（‘1’）与 Alice 鱼（‘0’）数量差 `sum`。只有当 `sum>0` 时，在这一位置划分一组才能为 Bob
带来正向增益，将所有这样的 `sum` 收集到 `vals` 中，排序后贪心取最大的增益，直到累计增益 ≥ k。

**关键步骤**

1. **后缀累积差分**
    - 初始化 `sum=0`，遍历 `i=n-1…1`：
      ```cpp
      sum += (s[i]=='1' ? 1 : -1);
      if (sum>0) vals.push_back(sum);
      ```
2. **贪心选组**
    - 将 `vals` 排序升序，设 `ans=1`（至少一组）。
    - 反复取出 `vals.back()`：
      ```cpp
      while (k>0 && !vals.empty()) {
        k -= vals.back();
        vals.pop_back();
        ++ans;
      }
      ```
3. **输出结果**
    - 若最终 `k>0` 则输

# P1173. 旅行计划

link: https://www.luogu.com.cn/problem/P1137

**标签**：DAG DP、拓扑排序、最长路径

**本质思路**  
将“只能从西向东”限制视作一个有向无环图（DAG），在 DAG 上对每个节点求最长可达路径长度。

**关键步骤**

1. **建图与初始化**
    - 用邻接表 `g[x]` 存储有向边 `x→y`，并用 `in[y]++` 记录每个节点的入度；
    - 数组 `dp[i]=1`，表示以节点 i 结尾的最长路径至少包含自己。

2. **拓扑排序 (Kahn 算法)**
    - 将所有 `in[i]==0` 的节点入队；
    - 依次弹出队首 `u`，并处理其每条出边 `u→v`。

3. **DP 松弛**
   ```cpp
   dp[v] = max(dp[v], dp[u] + 1);
   if (--in[v] == 0) q.push(v);

# F. 整除最长链

link: https://codeforces.com/problemset/problem/566/F

**标签**：DAG DP、筛法、数论、最长链

**本质思路**  
最大团即全互整除的元素集合，在整除关系偏序（DAG）上求最长链,变成了DAG on DP

示意图:

       3
     / | \
    v  v  v
    6  9  12
     \  |    \
      vv     v
      18     24
       \     /  \
        v   v    v
         72      48

**关键步骤**

1. **标记出现**
    - `has[i] = true` 表示元素 `i` 在输入集合中出现；
2. **初始化 DP**
    - `dp[i] = 1`，表示单个元素自成长度为 1 的链；
3. **升序枚举 & 埃氏筛**

  ```cpp
   for (int x : a) {
       // 枚举 x 的所有倍数 y
       for (int y = x * 2; y < N; y += x) {
           if (has[y])
               dp[y] = max(dp[y], dp[x] + 1);
       }
   }
 ```

# 陕西2024 C. 换座位

**link**：https://codeforces.com/gym/105257/problem/C

**标签**：拓扑排序、环检测、DAG on DP

**本质思路**  
将每位嘉宾视为节点 \(1\ldots n\)，每个目标座位视为节点 \(1\ldots2n\)，连一条有向边 \(i\to a_i\)。此图由若干「基环树」和「指向空座的树」组成。

- 对于指向空座（编号 \(>n\)）的树，用拓扑 BFS 剥离「树枝」，维护从根到当前节点的最长链长，更新到各空座。
- 对于剩下的入度 \(>0\) 的节点，即在环上，这些环上的嘉宾可以全部就座。  
  整体时间 \(O(n)\)、空间 \(O(n)\)。

**关键步骤**

1. **建图与入度统计**
    - 数组 `to[1..n]` 存储每位嘉宾的目标座位
    - `indeg[x]++` 用来统计每个节点的入度

2. **拓扑 BFS 求「最长链」**
    - 所有 `indeg[i]==0`（嘉宾）入队，设 `dist[i]=1`
    - 取出队头 \(x\)：
        - 若 `to[x]>n`，更新 `seatLen[to[x]] = max(seatLen[to[x]], dist[x])`
        - 否则
            1. `dist[to[x]] = max(dist[to[x]], dist[x]+1)`
            2. `if (--indeg[to[x]]==0)` 则入队

3. **环上节点计数**
    - BFS 结束后，所有 `1≤i≤n` 且 `indeg[i]>0` 的节点均处在环上，记作 `环上人数`

4. **答案汇总**  
   环上人数+各空座的最大链长

# G. 消失的数字

**link**：https://codeforces.com/gym/104921/problem/G

**标签**：进制转换、字符串处理、映射

**本质思路**  
将需要删除所有含 x 的自然数，等价于把数字集合 \{0,1,…,9\} 中去掉 x 后映射到 0~8，共九个“字符”，令原数在此基底下即为一个九进制数；转换为十进制并加
1 即为它在“未消失”序列中的排名。

**关键步骤**

1. **映射数字**  
   将 \(n\) 转为字符串 \(s\)，对每个字符 \(d\)：
    - 若 \(\,d>x\)，则替换为字符 \((d-1)\)
    - 否则保持不变
2. **九进制求值**  
   从高位到低位遍历映射后的 \(s\)，维护

3. **加一修正**  
   因为序列包含 \(0\)，最终排名应为 \(\text{ans}+1\)。

整体复杂度：\(O(|s|)\)，空间复杂度：\(O(|s|)\)

# A. 函数最大子段和

link: https://codeforces.com/problemset/problem/788/A

**标签**：差分、交替符号、最大子段和、Kadane、一维DP

**本质思路**  
将原数组转化为相邻差分并交替赋予正负符号，问题变为在一维数组上求最大子段和，使用Kadane算法在线性时间内完成。

**关键步骤**

构造奇偶下标开头+-差分数组,分别执行一遍Kadane算法

- 时间：\(O(n)\)
- 空间：\(O(n)\)

# D. 阿尔卡彭苹果树

link: https://codeforces.com/problemset/problem/1056/D

**标签**：树形 DP、子树统计、排序、Order‐Statistic

**本质思路**  
每个节点要幸福，当且仅当其子树中的叶子数 ≤ 颜色数。将所有节点的“需求”——子树叶子数——统计出来并排序，第 k 小的需求即为使 ≥ k
个节点幸福所需的最少颜色数。

**关键步骤**

1. **树形 DFS 统计叶子数**
    - 从根节点 1 开始递归计算每个节点叶子数量

2. **收集并排序**
    - 将 `leaf[1…n]` 放入数组，升序排序。
3. **直接取第 k 小**
    - 对于每个 k=1…n，输出排序后数组的第 k 项。

**复杂度**

- 时间：一次 DFS O(n) + 排序 O(n log n) = **O(n log n)**
- 空间：O(n)

# C. 粒子反射

**link**：<https://codeforces.com/problemset/problem/1498/C>

**标签**：动态规划、记忆化搜索、三维状态

## 本质思路

将“粒子穿透 + 衰减复制”过程抽象为三维 DP：

- 状态 `dp[i][k][d]` 表示“一个衰减度为 k 的粒子，从第 i 个平面以方向 d（0=左，1=右）射入，最终能产生的粒子总数”。
- 每到一个平面，粒子“自己继续穿透” + “产生一个 k−1 的反向副本”，两者都要计数。
- 边界 k == 1 时，不再复制，`dp[i][1][*] = 1`。

# B. 建筑公司

link: [https://codeforces.com/gym/104417](https://codeforces.com/gym/104417)

**标签**：拓扑排序、贪心、离线扫描

**本质思路**
将每个工程的“需求”当作依赖入度，满足所有需求的工程即入度为0。承接工程会增加员工（状态单调），触发其他工程入度减少，相当于在隐式依赖图上做拓扑排序。

**关键步骤**

1. **收集**：构造 `condition[t]`（工种需求列表）和 `prise[i]`（工程奖励），维护 `in[i]` 为剩余需求数。
2. **离线排序**：对每个 `condition[t]` 按需求人数排序，初始扫描一次减少可满足的入度。
3. **拓扑队列**：所有 `in[i]==0` 入队，循环取出工程，累加奖励后对相关 `condition[t]` 扫描并动态降低 `in[j]`，新 `in[j]==0`
   则入队。
4. **计数**：出队次数即为答案。

**复杂度**
令 $M=\sum m_i+\sum k_i$，$T$ 为工种种类数，总体 $O(M\log M + M\log T + n)$。

# C. Wonderful City

link: [https://codeforces.com/contest/2096/problem/C](https://codeforces.com/contest/2096/problem/C)

**标签**：动态规划、网格、状态压缩、矩阵转置

**本质思路**
将行操作与列操作对水平/垂直冲突的影响分离，分别用「对每行/列做或不做+1操作」的二状态动态规划求最小花费，再相加。

---

## 关键步骤

1. **分治冲突类型**

   * 行操作只影响垂直相邻；列操作只影响水平相邻。
   * 因此可先独立消除垂直冲突，再独立消除水平冲突。

2. **行上 DP 定义**

   * $dp[i][x]$：处理到第 $i$ 行，且对第 $i$ 行执行状态 $x\in\{0,1\}$（0=不加，1=加一）的最小成本。

3. **状态转移**
   对每一行 $i\ge2$，枚举当前 $x$ 与上一行 $y$：

   * 检查所有列 $j$ ：
     $h_{i-1,j} + y \neq h_{i,j} + x$
   * 若所有列都不等，则
     $dp[i][x] = \min(dp[i][x],\; dp[i-1][y] + x\cdot cost_i)$

4. **边界**
   $dp[1][0] = 0,\quad dp[1][1] = cost_1$

5. **求解列冲突**
   将矩阵转置，列操作视为对转置后“行”操作，复用同样的 DP 函数。

6. **合并答案**
   垂直最优 + 水平最优；若任一为无解（∞），输出 -1。

# D. 精彩的灯泡

link: [https://codeforces.com/contest/2096/problem/D](https://codeforces.com/contest/2096/problem/D)

**标签**：不变式、模2、哈希统计、坐标几何

**本质思路**
利用翻转操作对 4 个灯泡的「模 2 奇偶不变性」，分别在竖线 $x=c$ 和对角线 $x+y=c$ 上统计开灯数的奇偶，从而唯一定位初始亮灯坐标 $(s,t)$。

---

## 关键步骤

1. **模 2 奇偶不变**

   * 初始只有一个灯亮 → 奇数。每次操作切换 4 盏 → 保持总开灯数奇数。
   * 操作每条竖线/对角线上的灯,每次都是改变两个,奇偶性不变,只与初始是否有灯亮着有关

2. **统计竖线奇偶确定 $s$**

   * 用哈希表 `x_cnt[x]` 记录所有开灯点的横坐标频次。
   * 唯一出现奇数次的横坐标即为宝藏的横坐标 $s$。

3. **统计对角线奇偶确定 $s+t$**

   * 用哈希表 `plus_cnt[x+y]` 记录每个对角线（主对角线族）上开灯数。
   * 唯一奇数次的键值为 $s+t$。

4. **求出 $t$**
   $t = (s+t) - s.$
---
**时间复杂度**：$O(n\log n)$（map 统计）
**空间复杂度**：$O(n)$
