# D. 音乐预测

link: https://codeforces.com/contest/2042/problem/D

**标签**：扫描线、区间覆盖、离线处理、平衡树、有序集合、对称化

**本质思路**  
通过离线处理（按左端排序）和有序集合（`std::set.lower_bound`）将时间复杂度从 \(O(n^2)\) 降到 \(O(n\log n)\)。

**关键步骤**

1. **离线排序**  
   将所有区间按 \((l\ ↑,\ r\ ↓)\) 排序，保证遍历到 \([l_i,r_i]\) 时，所有满足 \(l_j\le l_i\) 的候选 predictors 已加入数据结构。
2. **在线查询**  
   用 `set<int>` 存放已处理区间的右端点，在遍历时用 `lower_bound(r_i)` 找到最小的 \(r_j\ge r_i\)，即 predictors 交集的右端，累加
   \(\max(0,\,r_j - r_i)\)。
3. **对称化处理**  
   将区间映射为 \([-r,-l]\) 后复用同样流程，得到左端推荐长度 \(\max(0,\,l_i - L)\)。
4. **去重**  
   相同原始区间的用户答案置 0。

整体复杂度：两次 \(O(n\log n)\) 扫描，合计 \(O(n\log n)\)。
