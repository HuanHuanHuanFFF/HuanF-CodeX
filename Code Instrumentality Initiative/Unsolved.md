### A. 贪吃蛇

**link**：https://codeforces.com/gym/105423  
**标签**：几何建模、向量运算、DAG 最长路径、拓扑排序  
**简单思路**：

1. 枚举两点差向量作为蛇头初始方向；
2. 用点积 ≥ 0 保证夹角 ≤ 90°，再结合叉积符号约束旋转方向，判断从当前点能否转向下一个点；
3. 将所有合法转向构造成有向无环图（DAG），对 DAG 做入度拓扑 BFS，维护 `dis[v]=max(dis[v],dis[u]+1)`，最终得最长路径长度。

### J. Beautiful Sequence

**link**：https://codeforces.com/gym/105423  
**标签**：哈希、线段树、双指针、子序列

**简单思路**：

1. 预处理两个排列中每个值在序列 1 和序列 2 中的下标映射 `pos1[i]`、`pos2[i]`
2. 使用双指针枚举区间右端 `r`，在区间 `[l…r]` 上通过线段树（或 BIT）维护子序列的相对顺序哈希
3. 对每个 `r`，移动左指针 `l` 直到区间在两序列中哈希相等，保持美丽序列性质
4. 每次固定 `r` 时，合法的美丽序列个数为 `r - l + 1`，累加到答案
5. 时间复杂度 O(n log n)，空间复杂度 O(n)

### H. 经文

**link**：https://codeforces.com/gym/105423  
**标签**：字符串、KMP、DP

**简单思路**：

1. 预处理模式串 s 的 KMP next 数组 `next[i][c]`，表示已匹配前缀长度 i 遇到字符 c 后转移到的新匹配长度
2. 定义三维 DP：`dp[i][j][t]` 表示已构造长度 i，恰好包含 j 个不重叠的 s，且当前已匹配前缀长度为 t 的方案数
3. 转移时枚举下一个字符 c∈‘a’…‘z’，计算 `nt=next[t][c]`
    - 若 `nt==|s|`，说明又匹配完一次 s，匹配数要 +1，新的匹配长度置为 `next[nt][c]`（或 0）
    - 否则新的匹配长度为 `nt`
    - `dp[i+1][j+(nt==|s|)][t′] += dp[i][j][t]`
4. 答案为 `sum(dp[n][k][t]) (0≤t<|s|) mod 998244353`

时间复杂度 O(26·n·k)，空间可用滚动数组优化到 O(k·|s|)  
