# Lucas 定理

## 文档概述

本篇文档介绍 Lucas 定理的背景、定理陈述、算法步骤及示例代码，帮助在模素数 $p$ 下高效计算组合数 $C(n,k) mod p$。

---

## 前置知识

1. **组合数与阶乘**： $C(n,k)=n!/(k!(n-k)!)$
2. **模 $p$ 下逆元（费马小定理）**： $a^{-1}=a^{p-2} mod p$
3. **$p$ 进制表示**： 将整数 $n,k$ 写作 $n=n_mn_{m-1}...n_0, k=k_mk_{m-1}...k_0$

---

## 定理陈述

若 $p$ 为素数，令 $n,k$ 在 $p$ 进制各位为 $n_i,k_i$，则

$C(n,k)=prod_{i=0}^m C(n_i,k_i) mod p$

若任意 $k_i>n_i$，结果为 0。

---

## 算法步骤

1. **预处理（$O(p)$）**  
   计算 $fac[i]=i! mod p$ 和 $ifac[i]=(i!)^{-1} mod p$。
2. **定义小规模组合**  
   $C(a,b)=fac[a]*ifac[b]*ifac[a-b] mod p$
3. **Lucas 递归**

```cpp
ll Lucas(ll n, ll k) {
    if (k == 0) return 1;
    return C(n % p, k % p) * Lucas(n / p, k / p) % p;
}
````

4. **返回结果**
   调用 $Lucas(n,k)$ 即得 $C(n,k)$ mod p。

总体复杂度：$O(p+log_p n)$。

---

## mod 2 特殊情况

### 常用于谢尔宾斯基三角形的生成,相当于杨辉三角挖去内部的偶数

当 $p=2$ 时，$C(n,k) mod 2$ 仅取决于二进制位，无需预处理。

判定条件：$C(n,k)$ 奇当且仅当在二进制上 $k$ 的每个 1 位均由 $n$ 的对应位覆盖，即

$ (k $&$ (n - k)) == 0 $

简易实现：

```cpp
bool binom_odd(ll n, ll k) {
    return (k & (n - k)) == 0;
}
```

---

## 应用场景

* **大规模组合数**：当 $n,k$ 高达 $10^{18}$ 且 $p$ 较小时快速计算。
* **数论竞赛**：常见于组合计数题。

