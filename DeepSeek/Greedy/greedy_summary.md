# Greedy Patterns 总结

下面是一些常见的贪心套路和它们背后的思想，以及今天练习的题目示例，帮助快速识别和解决贪心题目。

---

## 1. 排序 + 线性扫描

- **思路**：先对关键值（权重、区间端点、恐惧值等）**升序或降序**排序。  
- **执行**：从头/尾一次遍历，**立刻**根据条件做决策（成团、接纳、匹配等）。  
- **优势**：只需 \(O(n\log n)\) 排序 + \(O(n)\) 遍历，简单高效。  
- **示例**：  
  - **Young Explorers (1355B)**：恐惧值升序，`cnt++` 到 `cnt ≥ f[i]` 就成团。  
  - **Quality vs Quantity (1646B)**：成绩排序后，从最大往前累 `sum`，若 `sum + a[i] ≥ x·(cnt+1)` 则接纳。  

---

## 2. 只看「最难/最关键」的元素

- **核心**：一组/一个窗口里，通常只有一个元素最难满足（最大恐惧值、最大左端点…）。  
- **做法**：维护一个变量或预处理结构，只判断该关键元素，其他自然满足。  
- **示例**：  
  - **Maximal Intersection (1029C)**：删除一个后剩余的交集长度由最大左端点和最小右端点决定，前缀/后缀预处理后 \(O(1)\) 取。  
  - **Young Explorers (1355B)**：只需关心当前组的最大恐惧值，`cnt ≥ f[i]` 即可。  

---

## 3. 数据结构动态维护最优

- **用途**：当需要在「剩余元素集合」中频繁**查询最小/最大**或做增删时。  
- **常见**：  
  - `set` / `priority_queue`：挑最优（最小/最大）元素；  
  - 前缀/后缀数组：\(O(1)\) 取区间 max/min；  
  - 栈 / 双端队列：做括号匹配、流水线结构。  
- **示例**：  
  - **Heavy Intervals (1909C)**：用栈做括号匹配配对区间端点，保证无交叉后排序。  
  - **Darius’ Wisdom (2034D)**：三组集合 `pos[val]` 动态维护，交换时实时查询最优。  

---

## 4. 拆解大操作为「差1」的小步骤

- **场景**：直接操作不满足约束（如只能每步±1）时。  
- **策略**：分成两步或多步，每步只做最小单位的合法操作。  
- **示例**：  
  - **Darius’ Wisdom (2034D)**：把一次 `0↔2` 拆成 `1↔2` 再 `0↔1`。  
  - **Move to the End (2104B)**：移一个元素到末尾，用两次差1操作调整。  

---

## 5. 交换论证 + 重排不等式

- **目的**：在配对/匹配题中，证明某种「标准匹配 + 排序」最优。  
- **步骤**：  
  1. 用**交换**证明任何交叉或非标准匹配都能通过交换端点不增成本；  
  2. 对得到的长度/差值升序，对权重降序，一一对应最小化\(\sum c_i \Delta_i\)。  
- **示例**：  
  - **Heavy Intervals (1909C)**：端点括号匹配 + 长度排序配权重。  

---

以上内容结合了今天练习的主要题目，希望对你后续做贪心题有帮助！🚀🐾
