# P3586 \| POI 2015 **LOG** 题解

## 题意（Problem）

给定长度 `n (≤10^6)` 的序列，初值全 0。

- **U k a**：把第`k`个数改成`a`。
- **Z c s**：虚拟执行 `s`轮操作，每轮必须选恰好 `c` 个正数全部减 1，问能否做到（不真正修改序列）。

---

## 思路（Idea）

1. **总需求**：`c × s` 次 -1。
2. **按阈值 s** 把元素分两堆
    - **大块** `(a_i ≥ s)`：每个最多被选`s`次，共`k`个 ⇒ 贡献上限`k s`。
    - **小块** `(a_i < s)`：能被选的次数之和 ≤ 它们的总和`sum`。
3. **判定式**  
   \[
   sum \;\ge\; (c-k)s
   \]
    - 若`k ≥ c`直接可行；
    - 否则缺`(c-k)s`次，需由小块填补。

---

## 证明（Proof）

### 必要

若`sum < (c-k)s`，小块供给不足，必失败。

### 充分——贪心 + 反证

**贪心策略**

- 每轮选全部大块；
- 小块里挑当前值最大的`(c-k)`个减 1。

**反证**  
假设第`t (≤s)`轮无法凑满`c`个正数：

- 已消耗小块`(t-1)(c-k)`次；
- 若小块枯竭 ⇒`(t-1)(c-k) > sum`；
- 但 `t ≤ s` 且 `sum ≥ (c-k)s` ⇒ 不可能。  
  故条件亦充分。

---

## 实现（How to Implement）

1. **离线值域压缩**  
   收集所有 `a` 与 `s` 再加 0，排序去重得`pool[1‥M]`。
2. **两棵 Fenwick（BIT）**

| 名称       | 存储     | 用途                         |
|----------|--------|----------------------------|
| `BITcnt` | 各值出现次数 | 计算 `k = # {a_i ≥ s}`       |
| `BITsum` | 各值总和   | 计算 `sum = Σ_{a_i < s} a_i` |

3. **操作**
    - **U**：删旧值 + 插新值，各一次`add`。
    - **Z**：
        1. `id = idx(s)`；
        2. `k = n - BITcnt.sum(id-1)`；
        3. `sum = BITsum.sum(id-1)`；
        4. 判断 `k ≥ c` 或 `sum ≥ (c-k)s`。

---

## 代码解析（Code Walk-through）

```cpp
▲ 21-43   BIT<T>        // 经典单点增/前缀和结构
▲ 46-61   读入 + 离散   // opt 保存操作；a 收集所有 y
▲ 63-74   压缩映射      // rank[i] 为 opt[i] 的 y 在 pool 中坐标
▲ 78-93   主循环
  ├─U: 删旧值 → 插新值
  │     inv = BITcnt, pre = BITsum
  └─Z: id=rank[cnt]
       k   = inv.query(id,m)       // ≥ s
       sum = pre.pre_sum(id-1)     // < s
       ok  = ((-k+x)*1LL*y <= sum) // 判定式
```

- `inv = BITcnt`，`pre = BITsum`。
- `last_rank[x]` 记录当前位置对应的坐标，便于删除旧值。
- 复杂度 `O(m log m)`，内存 `O(n + m)`。

---

## 一句话总结

> **压缩值域 + 双 Fenwick，判定式 `sum ≥ (c-k)s`**，即可 AC 全题。
