# 线段树（Segment Tree）

## 什么是线段树？

线段树是一种二叉树结构，用于对数组或区间进行高效的区间查询与区间/点更新。

* **节点表示**：每个节点代表一个区间 `[l, r]`，根节点对应整个区间，叶节点对应单个元素。
* **合并操作**：节点的值通过将左右子区间的结果合并（如求和、取最值等）得到。
* **空间复杂度**：`O(4*N)`，常写成 `O(N)`。
* **时间复杂度**：每次查询或更新为 `O(log N)`。

## 常见应用场景

1. **无懒标记版本（点更新 + 区间查询）**

    * **区间和**、**区间最小/最大值**、**区间 GCD/OR/XOR** 等。

2. **有懒标记版本（区间更新 + 区间查询）**

    * **区间加值**、**区间赋值**、**区间翻转**、**区间取模** 等需要批量更新的场景。

3. **拓展功能**

    * **区间统计**：例如查询区间内小于 `K` 的个数（需权值线段树或分块）。
    * **第 k 大/第 k 小**：维护每个节点的有序集合或权值分布。
    * **Segment Tree Beats**：支持 `chmin`/`chmax` + 加法等复杂操作。

## 无懒标记模板

```cpp
// 支持点更新、区间查询
SegmentTree<int> seg(N,
    /* merge = */ [](int a,int b){ return a+b; },
    /* id_val = */ 0);
seg.build(a);
seg.update(pos, v);
int ans = seg.query(L, R);
```

核心要点：

* `build` 构造初始树；
* `update` 处理单点修改；
* `query` 返回区间合并结果。

## 有懒标记模板

```cpp
// 支持区间修改、区间查询（懒标记）
SegmentTree<ll,ll> seg(N,
    /* merge */ [](ll x,ll y){ return x+y; },
    /* apply */ [](ll &x,const ll &v){ x += v*len; },
    /* compose */ [](ll f,ll g){ return f+g; },
    /* id_val= */ 0,
    /* id_lz = */ 0);
seg.build(a);
seg.update(L, R, v);
ll ans = seg.query(L, R);
```

要点：

* `lz[p]` 存储待下推的修改值；
* `push` 将懒标记下传到子节点；
* `pull` 从子节点合并更新父节点；

---

通过以上模板，可根据需求替换合并、修改和组合函数，快速解决各类区间/点操作题目。
